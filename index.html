<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Plushlands — Biomes + Light Fog (Classic Water, single file)</title>

<!-- Import map -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
  }
}
</script>

<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#000; font-family:system-ui, sans-serif; }
  #hud { position:fixed; left:12px; top:12px; color:#fff; pointer-events:none; font-size:14px;
         text-shadow:0 1px 2px rgba(0,0,0,.7); background:rgba(0,0,0,.35);
         padding:8px 10px; border-radius:10px; backdrop-filter:blur(4px); }
  #help { position:fixed; left:50%; top:40%; transform:translateX(-50%); color:#fff; max-width:640px;
          background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.15); padding:18px 20px; border-radius:16px; }
  #help h1 { margin:0 0 10px; font-weight:700; }
  #lock { display:inline-block; margin-top:8px; padding:10px 16px; border-radius:999px;
          background:#73b8ff; color:#002; font-weight:700; cursor:pointer; }
  #crosshair { position:fixed; left:50%; top:50%; width:12px; height:12px; transform:translate(-50%,-50%);
               border-radius:50%; box-shadow:0 0 0 2px rgba(255,255,255,.85); opacity:.75; pointer-events:none; }
</style>
</head>
<body>
<div id="hud"><b>Plushlands</b> — WASD move • SPACE jump</div>
<div id="help"><h1>Click to enter :3</h1><div>Classic water + soft fog. No external images required.</div><div id="lock">Start</div></div>
<div id="crosshair"></div>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
import { Water } from 'three/addons/objects/Water.js';

/* ---------- utils ---------- */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const smoother=t=>t*t*t*(t*(6*t-15)+10);
function hash(ix,iz,seed=1337){let x=Math.imul(ix^seed,374761393)^Math.imul(iz+0x9e3779b9,668265263);x=(x^(x>>>13))>>>0;x=Math.imul(x,1274126177)>>>0;return (x>>>8)/16777216;}
function valueNoise2D(x,z,S=64,seed=1337){
  const gx=Math.floor(x/S),gz=Math.floor(z/S);
  const fx=(x/S)-gx,fz=(z/S)-gz, u=smoother(fx), v=smoother(fz);
  const v00=hash(gx,gz,seed), v10=hash(gx+1,gz,seed), v01=hash(gx,gz+1,seed), v11=hash(gx+1,gz+1,seed);
  return lerp( lerp(v00,v10,u), lerp(v01,v11,u), v )*2-1;
}
function fbm2D(x,z,oct=5,baseScale=180,seed=1337){
  let amp=1,freq=1,sum=0,norm=0;
  for(let i=0;i<oct;i++){ sum+=amp*valueNoise2D(x*freq,z*freq,baseScale,seed+i*101); norm+=amp; amp*=0.5; freq*=2; }
  return sum/norm;
}

/* ---------- world config ---------- */
const CHUNK_SIZE=160, CHUNK_RES=60, VIEW_RADIUS=3;
const PLAYER_HEIGHT=1.7, GRAVITY=28, MOVE_ACCEL=65, MOVE_DAMP=10, JUMP_VEL=9.6;
const TERRAIN_AMPLITUDE=22, SEA_LEVEL=0.0;
const DAY_MINUTES=4;

/* ---------- three setup ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x88c6ff);
const BASE_FOG = 0.0013;
scene.fog = new THREE.FogExp2(0x88c6ff, BASE_FOG);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1100);
camera.position.set(8, PLAYER_HEIGHT+2, 8);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new PointerLockControls(camera, renderer.domElement);
const help = document.getElementById('help');
document.getElementById('lock').onclick = ()=>controls.lock();
controls.addEventListener('lock', ()=> help.style.display='none');
controls.addEventListener('unlock', ()=> help.style.display='');

/* ---------- lights ---------- */
const sun = new THREE.DirectionalLight(0xffffff, 1.0); sun.position.set(100,200,80); scene.add(sun);
const ambient = new THREE.AmbientLight(0xffffff, 0.35); scene.add(ambient);

/* ---------- height ---------- */
function heightAt(x,z){
  const h = fbm2D(x,z,5,220,2025)*TERRAIN_AMPLITUDE + fbm2D(x+5000,z-8000,3,60,9001)*5;
  const ridge = Math.abs(fbm2D(x-12000,z+11111,3,300,7777));
  return h + ridge*8 - 2;
}

/* ---------- biomes ---------- */
function climateAt(x,y,z){
  const t = fbm2D(x+12345,z-54321,4,1600,5522)*0.5+0.5;
  const m = fbm2D(x-33333,z+22222,4,1400,9911)*0.5+0.5;
  const alt = clamp((y-SEA_LEVEL)/28,-1,2);
  return { T: clamp(t - alt*0.45,0,1), M: clamp(m,0,1) };
}
function biomeAt(x,y,z){
  if (y < SEA_LEVEL + 0.4) return 'beach';
  const {T,M} = climateAt(x,y,z);
  if (y>20) return 'alpine';
  if (T>.65 && M<.35) return 'desert';
  if (T>.60 && M>.55) return 'meadow';
  if (T<.35 && M>.55) return 'taiga';
  if (T<.30 && M<.45) return 'tundra';
  if (M>.60) return 'forest';
  if (M<.35) return 'shrubland';
  return 'meadow';
}
const TINT={
  beach:new THREE.Color(.85,.78,.56), desert:new THREE.Color(.86,.78,.52),
  shrubland:new THREE.Color(.55,.60,.42), meadow:new THREE.Color(.34,.62,.30),
  forest:new THREE.Color(.22,.44,.26), taiga:new THREE.Color(.30,.50,.40),
  tundra:new THREE.Color(.62,.66,.64), alpine:new THREE.Color(.75,.80,.85)
};

/* ---------- procedural textures (no external files) ---------- */
function makeGrassTexture(size=512){
  const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
  // gradient base
  const grad=g.createLinearGradient(0,0,0,size);
  grad.addColorStop(0,'#72c26f'); grad.addColorStop(1,'#5aa85a'); g.fillStyle=grad; g.fillRect(0,0,size,size);
  // tiny speckles + blades
  g.globalAlpha=0.25;
  for(let i=0;i<2200;i++){ g.fillStyle=Math.random()<0.5?'#2f6a2f':'#83c783'; const r=Math.random()*1.4+.3;
    g.beginPath(); g.arc(Math.random()*size, Math.random()*size, r, 0, 6.283); g.fill(); }
  g.globalAlpha=0.9;
  for(let i=0;i<1200;i++){ const x=Math.random()*size, y=Math.random()*size, l=6+Math.random()*12, a=-Math.PI/2+(Math.random()*0.6-0.3);
    g.beginPath(); g.moveTo(x,y); g.lineTo(x+Math.cos(a)*l,y+Math.sin(a)*l); g.lineWidth=1; g.strokeStyle='#4fa554'; g.stroke(); }
  const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.colorSpace=THREE.SRGBColorSpace; tex.anisotropy=renderer.capabilities.getMaxAnisotropy?.() ?? 1; return tex;
}
function makeDirtTexture(size=256){
  const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
  g.fillStyle='#6e553b'; g.fillRect(0,0,size,size);
  for(let i=0;i<2000;i++){ const r=Math.random()*1.6+.2; g.fillStyle=Math.random()<.5?'rgba(70,50,30,.25)':'rgba(160,130,100,.18)';
    g.beginPath(); g.arc(Math.random()*size, Math.random()*size, r, 0, 6.283); g.fill(); }
  const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.colorSpace=THREE.SRGBColorSpace; tex.anisotropy=renderer.capabilities.getMaxAnisotropy?.() ?? 1; return tex;
}
function makeRockTexture(size=256){
  const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
  g.fillStyle='#808993'; g.fillRect(0,0,size,size);
  for(let i=0;i<1400;i++){ const w=Math.random()*3+.5,h=Math.random()*1.5+.3;
    g.fillStyle=Math.random()<.5?'rgba(60,66,72,.28)':'rgba(220,230,240,.14)';
    g.beginPath(); g.ellipse(Math.random()*size, Math.random()*size, w, h, Math.random()*3.14, 0, 6.283); g.fill(); }
  const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.colorSpace=THREE.SRGBColorSpace; tex.anisotropy=renderer.capabilities.getMaxAnisotropy?.() ?? 1; return tex;
}
const grassTex = makeGrassTexture();
const dirtTex  = makeDirtTexture();
const rockTex  = makeRockTexture();

/* ---------- terrain material (triplanar + slope, sRGB fix) ---------- */
const TEX_METERS = 4;
const terrainMat = new THREE.MeshStandardMaterial({
  vertexColors:true, flatShading:true, metalness:0, roughness:.95, map:grassTex
});
terrainMat.onBeforeCompile=(shader)=>{
  shader.uniforms.grassMap={value:grassTex}; shader.uniforms.dirtMap={value:dirtTex}; shader.uniforms.rockMap={value:rockTex};
  shader.uniforms.tileScale={value:1.0/TEX_METERS}; shader.uniforms.slopeStart={value:.35}; shader.uniforms.slopeEnd={value:.80}; shader.uniforms.triSharp={value:4.0};
  shader.vertexShader = shader.vertexShader
    .replace('#include <common>', `#include <common>\nvarying vec3 vWorldPos; varying vec3 vWorldNormal;`)
    .replace('#include <beginnormal_vertex>', '#include <beginnormal_vertex>\n vWorldNormal = normalize( mat3(modelMatrix) * objectNormal );')
    .replace('#include <begin_vertex>', '#include <begin_vertex>\n vWorldPos = (modelMatrix * vec4(transformed,1.0)).xyz;');
  shader.fragmentShader = shader.fragmentShader
    .replace('#include <common>', `#include <common>\nvarying vec3 vWorldPos; varying vec3 vWorldNormal; uniform sampler2D grassMap,dirtMap,rockMap; uniform float tileScale,slopeStart,slopeEnd,triSharp; vec3 srgbToLinear(vec3 c){return pow(c,vec3(2.2));} vec3 triSampleTex(sampler2D tex, vec3 aw, vec3 wp){ vec2 uvX=wp.zy*tileScale, uvY=wp.xz*tileScale, uvZ=wp.xy*tileScale; vec3 tx=texture2D(tex,uvX).rgb, ty=texture2D(tex,uvY).rgb, tz=texture2D(tex,uvZ).rgb; return srgbToLinear(tx*aw.x + ty*aw.y + tz*aw.z);} `)
    .replace('#include <map_fragment>', `vec3 n=normalize(vWorldNormal); vec3 aw=pow(abs(n),vec3(triSharp)); aw/=(aw.x+aw.y+aw.z+1e-5); vec3 grass=triSampleTex(grassMap,aw,vWorldPos); vec3 dirt=triSampleTex(dirtMap,aw,vWorldPos); vec3 rock=triSampleTex(rockMap,aw,vWorldPos); float slope=clamp(1.0-abs(n.y),0.0,1.0); float wg=1.0-smoothstep(slopeStart*.8,slopeStart,slope); float wd=smoothstep(slopeStart*.6,slopeEnd*.9,slope)*(1.0-smoothstep(slopeEnd*.9,slopeEnd,slope)); float wr=smoothstep(slopeEnd*.9,slopeEnd,slope); float wsum=wg+wd+wr+1e-5; vec3 baseTex=(grass*wg + dirt*wd + rock*wr)/wsum; diffuseColor.rgb=baseTex;`);
};
terrainMat.needsUpdate=true;

/* ---------- classic water (with fog) ---------- */
// make a small procedural normal texture for water
function makeWaterNormal(size=256){
  const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
  g.fillStyle='#8080ff'; g.fillRect(0,0,size,size);
  g.globalAlpha=0.5;
  for(let y=0;y<size;y+=2){
    const a = Math.sin(y*0.12)*8;
    g.strokeStyle='rgba(128,128,255,0.5)'; g.beginPath(); g.moveTo(0,y); g.lineTo(size,y+a); g.stroke();
  }
  const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; return t;
}
const waterNormals = makeWaterNormal(256);

const waterGeo = new THREE.PlaneGeometry(4000, 4000);
const water = new Water(waterGeo, {
  textureWidth: 512, textureHeight: 512,
  waterNormals,
  alpha: 0.9,
  sunDirection: new THREE.Vector3(),
  sunColor: 0xffffff,
  waterColor: 0x7ec8ff,
  distortionScale: 0.14,
  fog: true
});
water.rotation.x = -Math.PI/2;
water.position.y = SEA_LEVEL - 0.08;
water.renderOrder = 1;
scene.add(water);

/* ---------- chunked terrain ---------- */
const chunkMap=new Map();
const keyFor=(cx,cz)=>`${cx},${cz}`;
function buildChunk(cx,cz){
  const x0=cx*CHUNK_SIZE, z0=cz*CHUNK_SIZE;
  const geo=new THREE.PlaneGeometry(CHUNK_SIZE,CHUNK_SIZE,CHUNK_RES,CHUNK_RES); geo.rotateX(-Math.PI/2);
  const pos=geo.attributes.position; const colors=new Float32Array((CHUNK_RES+1)*(CHUNK_RES+1)*3);
  for(let i=0;i<pos.count;i++){
    const vx=pos.getX(i)+x0, vz=pos.getZ(i)+z0; const y=heightAt(vx,vz); pos.setY(i,y);
    const b=biomeAt(vx,y,vz), col=TINT[b]||new THREE.Color(.8,.8,.8);
    colors[i*3+0]=col.r; colors[i*3+1]=col.g; colors[i*3+2]=col.b;
  }
  geo.setAttribute('color', new THREE.BufferAttribute(colors,3));
  geo.computeVertexNormals();
  const mesh=new THREE.Mesh(geo, terrainMat); scene.add(mesh);
  mesh.position.set(cx*CHUNK_SIZE,0,cz*CHUNK_SIZE);
  chunkMap.set(keyFor(cx,cz), mesh);
  return mesh;
}
function ensureChunksAround(px,pz){
  const ccx=Math.floor(px/CHUNK_SIZE), ccz=Math.floor(pz/CHUNK_SIZE);
  const wanted=new Set();
  for(let dz=-VIEW_RADIUS; dz<=VIEW_RADIUS; dz++)
    for(let dx=-VIEW_RADIUS; dx<=VIEW_RADIUS; dx++){
      const cx=ccx+dx, cz=ccz+dz, k=keyFor(cx,cz); wanted.add(k);
      if(!chunkMap.has(k)) buildChunk(cx,cz);
    }
  for(const k of chunkMap.keys()){
    if(!wanted.has(k)){ const m=chunkMap.get(k); scene.remove(m); m.geometry.dispose(); chunkMap.delete(k); }
  }
}

/* ---------- input + movement ---------- */
const keys=new Set();
addEventListener('keydown',e=>{ if(e.code==='Space') e.preventDefault(); keys.add(e.code); });
addEventListener('keyup',e=>keys.delete(e.code));
const vel=new THREE.Vector3(); let canJump=false;

function updatePlayer(dt){
  if(!controls.isLocked) return;
  const f=new THREE.Vector3(), r=new THREE.Vector3();
  camera.getWorldDirection(f); f.y=0; f.normalize();
  r.crossVectors(f,new THREE.Vector3(0,1,0)).multiplyScalar(-1).normalize();
  const acc=new THREE.Vector3();
  if(keys.has('KeyW')) acc.add(f);
  if(keys.has('KeyS')) acc.add(f.clone().multiplyScalar(-1));
  if(keys.has('KeyA')) acc.add(r.clone().multiplyScalar(-1));
  if(keys.has('KeyD')) acc.add(r);
  if(acc.lengthSq()>0) acc.normalize().multiplyScalar(MOVE_ACCEL);

  vel.x += acc.x*dt; vel.z += acc.z*dt;
  vel.x -= vel.x*MOVE_DAMP*dt; vel.z -= vel.z*MOVE_DAMP*dt;
  vel.y -= GRAVITY*dt;

  if(keys.has('Space') && canJump){ vel.y=JUMP_VEL; canJump=false; }

  const p=camera.position;
  p.x += vel.x*dt; p.z += vel.z*dt; p.y += vel.y*dt;

  const groundY = heightAt(p.x, p.z) + PLAYER_HEIGHT;
  if(p.y < groundY){ p.y=groundY; vel.y=0; canJump=true; }
}

/* ---------- day/night + fog ---------- */
const clock=new THREE.Clock(); let timeOfDay=8.0, chunkTimer=0;
function updateDayNight(dt){
  const minutesPerSec=(24/(DAY_MINUTES*60));
  timeOfDay=(timeOfDay + dt*minutesPerSec*60) % 24;

  const t=(timeOfDay/24)*Math.PI*2;
  const elev=Math.sin(t), azim=Math.cos(t);
  sun.position.set(azim*200, Math.max(10, elev*220+120), elev*120);
  sun.intensity = clamp(0.1 + Math.max(0,elev)*0.9, 0.1, 1.2);
  ambient.intensity = 0.20 + Math.max(0,elev)*0.25;

  const dayCol=new THREE.Color(0x88c6ff), duskCol=new THREE.Color(0xf5b080), nightCol=new THREE.Color(0x0b1020);
  let sky=dayCol.clone();
  if(elev<0.1){ sky.lerp(nightCol, clamp((0.1-elev)/0.6,0,1)); }
  else if(elev<0.3){ sky.lerp(duskCol, clamp((0.3-elev)/0.2,0,1)); }
  scene.background.copy(sky); scene.fog.color.copy(sky);

  water.material.uniforms.sunDirection.value.copy(sun.position).normalize();

  let target = BASE_FOG;
  const twilight = clamp(0.25 - Math.max(0,elev), 0, 0.25) / 0.25;
  target += twilight * 0.0007;
  scene.fog.density = lerp(scene.fog.density, target, 0.05);
}

/* ---------- resize ---------- */
addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

/* ---------- loop ---------- */
function animate(){
  const dt=Math.min(clock.getDelta(), 0.05);
  chunkTimer -= dt; if(chunkTimer<=0){ ensureChunksAround(camera.position.x, camera.position.z); chunkTimer=0.25; }
  updateDayNight(dt);
  updatePlayer(dt);
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
ensureChunksAround(camera.position.x, camera.position.z);
animate();
</script>
</body>
</html>
