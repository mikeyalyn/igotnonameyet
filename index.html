<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Plushlands — 10-min Days + External Grass</title>

<!-- Import map -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
  }
}
</script>

<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#000; font-family:system-ui, sans-serif; }
  #hud { position:fixed; left:12px; top:12px; color:#fff; pointer-events:none; font-size:14px;
         text-shadow:0 1px 2px rgba(0,0,0,.7); background:rgba(0,0,0,.35);
         padding:8px 10px; border-radius:10px; backdrop-filter:blur(4px); }
  #help { position:fixed; left:50%; top:40%; transform:translateX(-50%); color:#fff; max-width:640px;
          background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.15); padding:18px 20px; border-radius:16px; }
  #help h1 { margin:0 0 10px; font-weight:700; }
  #lock { display:inline-block; margin-top:8px; padding:10px 16px; border-radius:999px;
          background:#73b8ff; color:#002; font-weight:700; cursor:pointer; }
  #crosshair { position:fixed; left:50%; top:50%; width:12px; height:12px; transform:translate(-50%,-50%);
               border-radius:50%; box-shadow:0 0 0 2px rgba(255,255,255,.85); opacity:.75; pointer-events:none; }
  #interact { position:fixed; left:50%; bottom:18%; transform:translateX(-50%); pointer-events:none; color:#fff;
              background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.2); padding:8px 12px; border-radius:999px;
              font-size:16px; opacity:0; transition:opacity .15s; }
  #inventory { position: fixed; right:12px; top:12px; width:260px; display:none; color:#fff;
               background: rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:12px; }
  #inventory h3 { margin:0 0 8px; }
  .grid { display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; }
  .slot { background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:8px; min-height:60px; }
  .label { font-size:12px; opacity:.85; }
  .count { font-size:18px; font-weight:700; }
</style>
</head>
<body>
<div id="hud"><b>Plushlands</b> — WASD move • SPACE jump • E pick up • I inventory • B campfire (3 sticks + 1 rock)</div>
<div id="help"><h1>Click to enter :3</h1>
  <div>10-minute day/night cycle. Using your <b>assets/grass.png</b> for terrain.</div>
  <div id="lock">Start</div>
</div>
<div id="crosshair"></div>
<div id="interact">E — Pick up</div>

<div id="inventory">
  <h3>Inventory</h3>
  <div class="grid">
    <div class="slot"><div class="label">Sticks</div><div id="c_stick" class="count">0</div></div>
    <div class="slot"><div class="label">Rocks</div><div id="c_rock" class="count">0</div></div>
    <div class="slot"><div class="label">Berries</div><div id="c_berry" class="count">0</div></div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
import { Water } from 'three/addons/objects/Water.js';

/* ===== utils ===== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const smoother=t=>t*t*t*(t*(6*t-15)+10);
function hash(ix,iz,seed=1337){let x=Math.imul(ix^seed,374761393)^Math.imul(iz+0x9e3779b9,668265263);x=(x^(x>>>13))>>>0;x=Math.imul(x,1274126177)>>>0;return (x>>>8)/16777216;}
function valueNoise2D(x,z,S=64,seed=1337){
  const gx=Math.floor(x/S),gz=Math.floor(z/S);
  const fx=(x/S)-gx,fz=(z/S)-gz, u=smoother(fx), v=smoother(fz);
  const v00=hash(gx,gz,seed), v10=hash(gx+1,gz,seed), v01=hash(gx,gz+1,seed), v11=hash(gx+1,gz+1,seed);
  return lerp( lerp(v00,v10,u), lerp(v01,v11,u), v )*2-1;
}
function fbm2D(x,z,oct=5,baseScale=180,seed=1337){
  let amp=1,freq=1,sum=0,norm=0;
  for(let i=0;i<oct;i++){ sum+=amp*valueNoise2D(x*freq,z*freq,baseScale,seed+i*101); norm+=amp; amp*=0.5; freq*=2; }
  return sum/norm;
}

/* ===== world config ===== */
const CHUNK_SIZE=160, CHUNK_RES=60, VIEW_RADIUS=3;
const PLAYER_HEIGHT=1.7, GRAVITY=28, MOVE_ACCEL=65, MOVE_DAMP=10, JUMP_VEL=9.6;
const TERRAIN_AMPLITUDE=22, SEA_LEVEL=0.0;
const DAY_MINUTES=10;          // << 10-minute full day/night cycle
const ITEM_PER_CHUNK=14, PICKUP_DISTANCE=2.0;

/* ===== three setup ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x88c6ff);
const BASE_FOG = 0.0013;
scene.fog = new THREE.FogExp2(0x88c6ff, BASE_FOG);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1100);
camera.position.set(8, PLAYER_HEIGHT+2, 8);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new PointerLockControls(camera, renderer.domElement);
const help = document.getElementById('help');
document.getElementById('lock').onclick = ()=>controls.lock();
controls.addEventListener('lock', ()=> help.style.display='none');
controls.addEventListener('unlock', ()=> help.style.display='');

/* ===== lights ===== */
const sun = new THREE.DirectionalLight(0xffffff, 1.0); sun.position.set(100,200,80); scene.add(sun);
const ambient = new THREE.AmbientLight(0xffffff, 0.35); scene.add(ambient);

/* ===== height & biomes ===== */
function heightAt(x,z){
  const h = fbm2D(x,z,5,220,2025)*TERRAIN_AMPLITUDE + fbm2D(x+5000,z-8000,3,60,9001)*5;
  const ridge = Math.abs(fbm2D(x-12000,z+11111,3,300,7777));
  return h + ridge*8 - 2;
}
function climateAt(x,y,z){
  const t = fbm2D(x+12345,z-54321,4,1600,5522)*0.5+0.5;
  const m = fbm2D(x-33333,z+22222,4,1400,9911)*0.5+0.5;
  const alt = clamp((y-SEA_LEVEL)/28,-1,2);
  return { T: clamp(t - alt*0.45,0,1), M: clamp(m,0,1) };
}
function biomeAt(x,y,z){
  if (y < SEA_LEVEL + 0.4) return 'beach';
  const {T,M} = climateAt(x,y,z);
  if (y>20) return 'alpine';
  if (T>.65 && M<.35) return 'desert';
  if (T>.60 && M>.55) return 'meadow';
  if (T<.35 && M>.55) return 'taiga';
  if (T<.30 && M<.45) return 'tundra';
  if (M>.60) return 'forest';
  if (M<.35) return 'shrubland';
  return 'meadow';
}
const TINT={
  beach:new THREE.Color(.85,.78,.56), desert:new THREE.Color(.86,.78,.52),
  shrubland:new THREE.Color(.55,.60,.42), meadow:new THREE.Color(.34,.62,.30),
  forest:new THREE.Color(.22,.44,.26), taiga:new THREE.Color(.30,.50,.40),
  tundra:new THREE.Color(.62,.66,.64), alpine:new THREE.Color(.75,.80,.85)
};

/* ===== textures ===== */
// point this to your seamless PNG (default where you placed it)
const GRASS_URL = 'assets/grass.png';

const loader = new THREE.TextureLoader();
const grassTex = loader.load(GRASS_URL, (t)=>{ t.wrapS=t.wrapT=THREE.RepeatWrapping; t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=renderer.capabilities.getMaxAnisotropy?.() ?? 1; });

function makeDirtTexture(size=256){
  const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
  g.fillStyle='#6e553b'; g.fillRect(0,0,size,size);
  for(let i=0;i<2000;i++){ const r=Math.random()*1.6+.2; g.fillStyle=Math.random()<.5?'rgba(70,50,30,.25)':'rgba(160,130,100,.18)';
    g.beginPath(); g.arc(Math.random()*size, Math.random()*size, r, 0, 6.283); g.fill(); }
  const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.colorSpace=THREE.SRGBColorSpace; tex.anisotropy=renderer.capabilities.getMaxAnisotropy?.() ?? 1; return tex;
}
function makeRockTexture(size=256){
  const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
  g.fillStyle='#808993'; g.fillRect(0,0,size,size);
  for(let i=0;i<1400;i++){ const w=Math.random()*3+.5,h=Math.random()*1.5+.3;
    g.fillStyle=Math.random()<.5?'rgba(60,66,72,.28)':'rgba(220,230,240,.14)';
    g.beginPath(); g.ellipse(Math.random()*size, Math.random()*size, w, h, Math.random()*3.14, 0, 6.283); g.fill(); }
  const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.colorSpace=THREE.SRGBColorSpace; tex.anisotropy=renderer.capabilities.getMaxAnisotropy?.() ?? 1; return tex;
}
const dirtTex  = makeDirtTexture();
const rockTex  = makeRockTexture();

/* ===== terrain material (triplanar + slope, sRGB fix) ===== */
const TEX_METERS = 4;
const terrainMat = new THREE.MeshStandardMaterial({
  vertexColors:true, flatShading:true, metalness:0, roughness:.95, map:grassTex
});
terrainMat.onBeforeCompile=(shader)=>{
  shader.uniforms.grassMap={value:grassTex}; shader.uniforms.dirtMap={value:dirtTex}; shader.uniforms.rockMap={value:rockTex};
  shader.uniforms.tileScale={value:1.0/TEX_METERS}; shader.uniforms.slopeStart={value:.35}; shader.uniforms.slopeEnd={value:.80}; shader.uniforms.triSharp={value:4.0};
  shader.vertexShader = shader.vertexShader
    .replace('#include <common>', `#include <common>\nvarying vec3 vWorldPos; varying vec3 vWorldNormal;`)
    .replace('#include <beginnormal_vertex>', '#include <beginnormal_vertex>\n vWorldNormal = normalize( mat3(modelMatrix) * objectNormal );')
    .replace('#include <begin_vertex>', '#include <begin_vertex>\n vWorldPos = (modelMatrix * vec4(transformed,1.0)).xyz;');
  shader.fragmentShader = shader.fragmentShader
    .replace('#include <common>', `#include <common>\nvarying vec3 vWorldPos; varying vec3 vWorldNormal; uniform sampler2D grassMap,dirtMap,rockMap; uniform float tileScale,slopeStart,slopeEnd,triSharp; vec3 srgbToLinear(vec3 c){return pow(c,vec3(2.2));} vec3 triSampleTex(sampler2D tex, vec3 aw, vec3 wp){ vec2 uvX=wp.zy*tileScale, uvY=wp.xz*tileScale, uvZ=wp.xy*tileScale; vec3 tx=texture2D(tex,uvX).rgb, ty=texture2D(tex,uvY).rgb, tz=texture2D(tex,uvZ).rgb; return srgbToLinear(tx*aw.x + ty*aw.y + tz*aw.z);} `)
    .replace('#include <map_fragment>', `vec3 n=normalize(vWorldNormal); vec3 aw=pow(abs(n),vec3(triSharp)); aw/=(aw.x+aw.y+aw.z+1e-5); vec3 g=triSampleTex(grassMap,aw,vWorldPos); vec3 d=triSampleTex(dirtMap,aw,vWorldPos); vec3 r=triSampleTex(rockMap,aw,vWorldPos); float slope=clamp(1.0-abs(n.y),0.0,1.0); float wg=1.0-smoothstep(slopeStart*.8,slopeStart,slope); float wd=smoothstep(slopeStart*.6,slopeEnd*.9,slope)*(1.0-smoothstep(slopeEnd*.9,slopeEnd,slope)); float wr=smoothstep(slopeEnd*.9,slopeEnd,slope); float wsum=wg+wd+wr+1e-5; vec3 baseTex=(g*wg + d*wd + r*wr)/wsum; diffuseColor.rgb=baseTex;`);
};
terrainMat.needsUpdate=true;

/* ===== classic water (with fog) ===== */
function makeWaterNormal(size=256){ // simple procedural normal-ish
  const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
  g.fillStyle='#8080ff'; g.fillRect(0,0,size,size); g.globalAlpha=0.45;
  for(let y=0;y<size;y+=2){ const a=Math.sin(y*0.12)*8; g.strokeStyle='rgba(128,128,255,0.5)'; g.beginPath(); g.moveTo(0,y); g.lineTo(size,y+a); g.stroke(); }
  const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; return t;
}
const waterNormals = makeWaterNormal(256);
const waterGeo = new THREE.PlaneGeometry(4000, 4000);
const water = new Water(waterGeo, {
  textureWidth: 512, textureHeight: 512,
  waterNormals,
  alpha: 0.9,
  sunDirection: new THREE.Vector3(),
  sunColor: 0xffffff,
  waterColor: 0x7ec8ff,
  distortionScale: 0.14,
  fog: true
});
water.rotation.x = -Math.PI/2;
water.position.y = SEA_LEVEL - 0.08;
water.renderOrder = 1;
scene.add(water);

/* ===== chunked terrain ===== */
const chunkMap=new Map();
const keyFor=(cx,cz)=>`${cx},${cz}`;
function buildChunk(cx,cz){
  const x0=cx*CHUNK_SIZE, z0=cz*CHUNK_SIZE;
  const geo=new THREE.PlaneGeometry(CHUNK_SIZE,CHUNK_SIZE,CHUNK_RES,CHUNK_RES); geo.rotateX(-Math.PI/2);
  const pos=geo.attributes.position; const colors=new Float32Array((CHUNK_RES+1)*(CHUNK_RES+1)*3);
  for(let i=0;i<pos.count;i++){
    const vx=pos.getX(i)+x0, vz=pos.getZ(i)+z0; const y=heightAt(vx,vz); pos.setY(i,y);
    const b=biomeAt(vx,y,vz), col=TINT[b]||new THREE.Color(.8,.8,.8);
    colors[i*3+0]=col.r; colors[i*3+1]=col.g; colors[i*3+2]=col.b;
  }
  geo.setAttribute('color', new THREE.BufferAttribute(colors,3));
  geo.computeVertexNormals();
  const mesh=new THREE.Mesh(geo, terrainMat); scene.add(mesh);
  mesh.position.set(cx*CHUNK_SIZE,0,cz*CHUNK_SIZE);
  chunkMap.set(keyFor(cx,cz), mesh);
  spawnItemsInChunk(x0,z0); // add pickups into this chunk
  return mesh;
}
function ensureChunksAround(px,pz){
  const ccx=Math.floor(px/CHUNK_SIZE), ccz=Math.floor(pz/CHUNK_SIZE);
  const wanted=new Set();
  for(let dz=-VIEW_RADIUS; dz<=VIEW_RADIUS; dz++)
    for(let dx=-VIEW_RADIUS; dx<=VIEW_RADIUS; dx++){
      const cx=ccx+dx, cz=ccz+dz, k=keyFor(cx,cz); wanted.add(k);
      if(!chunkMap.has(k)) buildChunk(cx,cz);
    }
  for(const k of chunkMap.keys()){
    if(!wanted.has(k)){ const m=chunkMap.get(k); scene.remove(m); m.geometry.dispose(); chunkMap.delete(k); removeItemsInChunkKey(k); }
  }
}

/* ===== pickups & inventory ===== */
const inventory = { stick:0, rock:0, berry:0 };
const c_stick=document.getElementById('c_stick'), c_rock=document.getElementById('c_rock'), c_berry=document.getElementById('c_berry');
function updateInventoryUI(){ c_stick.textContent=inventory.stick; c_rock.textContent=inventory.rock; c_berry.textContent=inventory.berry; }
const itemsMap = new Map();
function removeItemsInChunkKey(k){
  const arr = itemsMap.get(k);
  if (!arr) return;
  for (const it of arr){ scene.remove(it.mesh); it.mesh.geometry?.dispose?.(); it.mesh.material?.dispose?.(); }
  itemsMap.delete(k);
}
function randInChunk(x0, z0){
  return [ x0 + (Math.random()*2-1)*(CHUNK_SIZE*0.5-4),
           z0 + (Math.random()*2-1)*(CHUNK_SIZE*0.5-4) ];
}
function makePickupMesh(type){
  if (type==='rock'){
    return new THREE.Mesh(new THREE.IcosahedronGeometry(0.3,0),
      new THREE.MeshStandardMaterial({ color:0x888888, roughness:1 }));
  }
  if (type==='stick'){
    const g=new THREE.CylinderGeometry(0.06,0.06,0.9,6);
    const m=new THREE.MeshStandardMaterial({ color:0x6b4e2e, roughness:0.9 });
    const mesh=new THREE.Mesh(g,m); mesh.rotation.z=(Math.random()*0.6-0.3); mesh.rotation.y=Math.random()*Math.PI; return mesh;
  }
  // berry bush
  const group=new THREE.Group();
  const base=new THREE.SphereGeometry(0.45,12,8,0,Math.PI*2,0,Math.PI/2);
  const bm=new THREE.MeshStandardMaterial({ color:0x2f6f2f, roughness:1.0 });
  const bush=new THREE.Mesh(base,bm); group.add(bush);
  for (let i=0;i<5;i++){
    const s=new THREE.Mesh(new THREE.SphereGeometry(0.08,10,8), new THREE.MeshStandardMaterial({ color:0xa11c3f, roughness:.7 }));
    s.position.set((Math.random()-0.5)*0.6, 0.2+Math.random()*0.2, (Math.random()-0.5)*0.6);
    group.add(s);
  }
  group.userData.isGroup = true;
  return group;
}
function spawnItemsInChunk(x0, z0){
  const cx=Math.round(x0/CHUNK_SIZE), cz=Math.round(z0/CHUNK_SIZE);
  const key = keyFor(cx,cz);
  const arr=[]; const n=Math.max(6, Math.floor(ITEM_PER_CHUNK*(Math.random()*0.6+0.7)));
  for (let i=0;i<n;i++){
    const type = Math.random()<0.38?'stick': (Math.random()<0.55?'rock':'berry');
    const [x,z]=randInChunk(x0, z0); const y=heightAt(x,z);
    if (y < SEA_LEVEL+0.2) continue;
    const mesh=makePickupMesh(type); mesh.position.set(x, y+(type==='berry'?0.02:0.05), z); scene.add(mesh);
    arr.push({ type, mesh, x, y, z, taken:false });
  }
  itemsMap.set(key, arr);
}
const interact = document.getElementById('interact');
function showInteract(msg){ interact.textContent=msg; interact.style.opacity=1; }
function hideInteract(){ interact.style.opacity=0; }
function nearestPickup(px,py,pz){
  let best=null, bestD=1e9;
  for (const items of itemsMap.values()){
    for (const it of items){
      if (it.taken) continue;
      const dx = it.x - px, dy = (it.y+0.3) - py, dz = it.z - pz;
      const d2 = dx*dx + dy*dy + dz*dz;
      if (d2 < bestD){ bestD = d2; best = it; }
    }
  }
  return best ? { item:best, dist: Math.sqrt(bestD) } : null;
}

/* ===== campfires ===== */
const campfires=[];
function buildCampfireAt(x,z){
  const g=new THREE.CylinderGeometry(0.18,0.18,0.5,6);
  const m=new THREE.MeshStandardMaterial({ color:0x5a3d27, roughness:0.95 });
  const log1=new THREE.Mesh(g,m), log2=log1.clone(), log3=log1.clone();
  const y = heightAt(x,z) + 0.25;
  log1.position.set(x,y,z); log2.position.set(x,y,z); log3.position.set(x,y,z);
  log1.rotation.z=0.4; log2.rotation.z=-0.4; log3.rotation.x=0.6;
  scene.add(log1,log2,log3);
  const flame=new THREE.Mesh(new THREE.SphereGeometry(0.22,16,12), new THREE.MeshBasicMaterial({ color:0xffb74d }));
  flame.position.set(x,y+0.1,z); scene.add(flame);
  const glow=new THREE.PointLight(0xffa040,1.6,15,1.5); glow.position.set(x,y+0.3,z); scene.add(glow);
  const baseI=glow.intensity; campfires.push({ glow, flame, t: Math.random()*100, baseI });
}
function updateCampfires(dt){
  for (const c of campfires){
    c.t += dt*8;
    c.glow.intensity = c.baseI * (0.75 + Math.sin(c.t)*0.25 + Math.random()*0.08);
    c.flame.scale.setScalar(0.8 + Math.random()*0.2);
  }
}

/* ===== input + movement ===== */
const keys=new Set();
addEventListener('keydown',e=>{ if(e.code==='Space') e.preventDefault(); keys.add(e.code); });
addEventListener('keyup',e=>keys.delete(e.code));
const vel=new THREE.Vector3(); let canJump=false;
let pickupCooldown = 0;

const invPanel = document.getElementById('inventory'); let inventoryOpen=false;
addEventListener('keydown', (e)=>{
  if (e.code === 'KeyI'){ inventoryOpen = !inventoryOpen; invPanel.style.display = inventoryOpen? 'block' : 'none'; }
  if (!controls.isLocked) return;
  if (e.code==='KeyE'){ tryPickup(); }
  if (e.code==='KeyB'){
    if (inventory.stick >= 3 && inventory.rock >= 1){
      inventory.stick -= 3; inventory.rock -= 1; updateInventoryUI();
      buildCampfireAt(camera.position.x, camera.position.z);
    }
  }
});
function tryPickup(){
  if (pickupCooldown > 0) return;
  const n = nearestPickup(camera.position.x, camera.position.y, camera.position.z);
  if (n && n.dist <= PICKUP_DISTANCE){
    const it = n.item; it.taken = true; scene.remove(it.mesh);
    inventory[it.type] = (inventory[it.type]||0) + 1; updateInventoryUI();
    pickupCooldown = 0.2;
  }
}
function updatePlayer(dt){
  if(!controls.isLocked) return;
  const f=new THREE.Vector3(), r=new THREE.Vector3();
  camera.getWorldDirection(f); f.y=0; f.normalize();
  r.crossVectors(f,new THREE.Vector3(0,1,0)).multiplyScalar(-1).normalize();
  const acc=new THREE.Vector3();
  if(keys.has('KeyW')) acc.add(f);
  if(keys.has('KeyS')) acc.add(f.clone().multiplyScalar(-1));
  if(keys.has('KeyA')) acc.add(r.clone().multiplyScalar(-1));
  if(keys.has('KeyD')) acc.add(r);
  if(acc.lengthSq()>0) acc.normalize().multiplyScalar(MOVE_ACCEL);

  vel.x += acc.x*dt; vel.z += acc.z*dt;
  vel.x -= vel.x*MOVE_DAMP*dt; vel.z -= vel.z*MOVE_DAMP*dt;
  vel.y -= GRAVITY*dt;
  if(keys.has('Space') && canJump){ vel.y=JUMP_VEL; canJump=false; }

  const p=camera.position;
  p.x += vel.x*dt; p.z += vel.z*dt; p.y += vel.y*dt;

  const groundY = heightAt(p.x, p.z) + PLAYER_HEIGHT;
  if(p.y < groundY){ p.y=groundY; vel.y=0; canJump=true; }
}

/* ===== day/night + fog (10-minute cycle) ===== */
const clock=new THREE.Clock(); let timeOfDay=8.0, chunkTimer=0;
function updateDayNight(dt){
// 24 game hours over DAY_MINUTES real minutes
const HOURS_PER_SEC = 24 / (DAY_MINUTES * 60);  // hours advanced each real second
timeOfDay = (timeOfDay + dt * HOURS_PER_SEC) % 24;


  const t=(timeOfDay/24)*Math.PI*2;
  const elev=Math.sin(t), azim=Math.cos(t);
  sun.position.set(azim*200, Math.max(10, elev*220+120), elev*120);
  sun.intensity = clamp(0.1 + Math.max(0,elev)*0.9, 0.1, 1.2);
  ambient.intensity = 0.20 + Math.max(0,elev)*0.25;

  const dayCol=new THREE.Color(0x88c6ff), duskCol=new THREE.Color(0xf5b080), nightCol=new THREE.Color(0x0b1020);
  let sky=dayCol.clone();
  if(elev<0.1){ sky.lerp(nightCol, clamp((0.1-elev)/0.6,0,1)); }
  else if(elev<0.3){ sky.lerp(duskCol, clamp((0.3-elev)/0.2,0,1)); }
  scene.background.copy(sky); scene.fog.color.copy(sky);

  water.material.uniforms.sunDirection.value.copy(sun.position).normalize();

  let target = BASE_FOG;
  const twilight = clamp(0.25 - Math.max(0,elev), 0, 0.25) / 0.25;
  target += twilight * 0.0007;
  scene.fog.density = lerp(scene.fog.density, target, 0.05);
}

/* ===== loop ===== */
function animate(){
  const dt=Math.min(clock.getDelta(), 0.05);
  chunkTimer -= dt; if(chunkTimer<=0){ ensureChunksAround(camera.position.x, camera.position.z); chunkTimer=0.25; }
  updateDayNight(dt);
  updatePlayer(dt);
  updateCampfires(dt);
  if (pickupCooldown>0) pickupCooldown -= dt;

  const n = nearestPickup(camera.position.x, camera.position.y, camera.position.z);
  if (controls.isLocked && n && n.dist <= PICKUP_DISTANCE){
    const name = n.item.type.charAt(0).toUpperCase()+n.item.type.slice(1);
    showInteract(`E — Pick up ${name}`);
  } else hideInteract();

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

/* ===== ui helpers ===== */
updateInventoryUI();

/* ===== boot ===== */
ensureChunksAround(camera.position.x, camera.position.z);
animate();

/* ===== resize ===== */
addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

</script>
</body>
</html>


