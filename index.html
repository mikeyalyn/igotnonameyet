<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Plushlands: Triplanar + Slope Blend + Flowers (Shader Fix)</title>

<!-- Import map for bare specifiers -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
  }
}
</script>

<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#000; font-family:system-ui, sans-serif; }
  #ui {
    position: fixed; inset: 0; pointer-events: none; color:#fff;
    text-shadow: 0 1px 2px rgba(0,0,0,.7);
  }
  #hud {
    position:absolute; left:12px; top:12px; pointer-events:none; font-size:14px; line-height:1.3;
    background: rgba(0,0,0,0.35); padding:8px 10px; border-radius:10px; backdrop-filter: blur(4px);
  }
  #interact {
    position:absolute; left:50%; bottom:18%; transform: translateX(-50%);
    pointer-events:none; font-size:16px; background: rgba(0,0,0,0.4);
    padding:8px 12px; border-radius:999px; opacity:0; transition: opacity .15s;
  }
  #crosshair {
    position:absolute; left:50%; top:50%; width:12px; height:12px; transform:translate(-50%,-50%);
    border-radius:50%; box-shadow: 0 0 0 2px rgba(255,255,255,.8);
    opacity:.7; pointer-events:none;
  }
  #help {
    position:absolute; left:50%; top:40%; transform:translateX(-50%); text-align:center; max-width:640px; padding:20px;
    background: rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.15); border-radius:16px; pointer-events:auto;
  }
  #help h1 { margin:0 0 10px; font-size:28px; }
  #help p { margin:6px 0; opacity:.95 }
  #lockBtn {
    display:inline-block; margin-top:10px; padding:10px 16px; border-radius:999px; background:#73b8ff; color:#002;
    text-shadow:none; font-weight:700; cursor:pointer; pointer-events:auto;
  }
  #inventory {
    position: absolute; right:12px; top:12px; width:260px; pointer-events:auto; display:none;
    background: rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:12px;
  }
  #inventory h3 { margin:0 0 8px; }
  .grid { display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; }
  .slot { background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:8px; min-height:60px; }
  .label { font-size:12px; opacity:.85; }
  .count { font-size:18px; font-weight:700; }
  #notice {
    position:absolute; right:12px; bottom:12px; background: rgba(0,0,0,.5);
    border:1px solid rgba(255,255,255,.15); border-radius:12px; padding:8px 12px; font-size:13px;
  }
</style>
</head>
<body>
<div id="ui">
  <div id="hud">
    <div><b>Plushlands</b> â€¢ WASD move, SPACE jump, I inventory, E pick up, B build campfire</div>
    <div id="status">time â€¦ | weather â€¦ | x â€¦ z â€¦</div>
  </div>
  <div id="interact">E â€” Pick up</div>
  <div id="crosshair"></div>
  <div id="help">
    <h1>Click to enter the world :3</h1>
    <p>Triplanar terrain, slope-based dirt/rock, and flowers ðŸŒ¸</p>
    <div id="lockBtn">Start</div>
    <p style="opacity:.8;margin-top:10px">Tip: open inventory with <b>I</b></p>
  </div>

  <div id="inventory">
    <h3>Inventory</h3>
    <div class="grid">
      <div class="slot"><div class="label">Sticks</div><div id="c_stick" class="count">0</div></div>
      <div class="slot"><div class="label">Rocks</div><div id="c_rock" class="count">0</div></div>
      <div class="slot"><div class="label">Berries</div><div id="c_berry" class="count">0</div></div>
    </div>
    <div style="margin-top:10px; font-size:12px; opacity:.9">
      Build campfire: <b>3 sticks + 1 rock</b> then press <b>B</b>
    </div>
  </div>

  <div id="notice">v0.3.1 â€” Shader compile fix âœ…</div>
</div>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

/*** ---------- Helpers ---------- ***/
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a,b,t) => a + (b-a)*t;
const smoothstep = (t)=>t*t*(3-2*t);
const smoother = (t)=>t*t*t*(t*(6*t-15)+10); // smootherstep

// Deterministic hash â†’ [0,1)
function hash(ix, iz, seed=1337){
  let x = Math.imul(ix ^ seed, 374761393) ^ Math.imul(iz + 0x9e3779b9, 668265263);
  x = (x ^ (x >>> 13)) >>> 0;
  x = Math.imul(x, 1274126177) >>> 0;
  return (x >>> 8) / 16777216;
}

// 2D Value noise
function valueNoise2D(x, z, S=64, seed=1337){
  const gx = Math.floor(x / S), gz = Math.floor(z / S);
  const fx = (x / S) - gx, fz = (z / S) - gz;
  const u = smoother(fx), v = smoother(fz);
  const v00 = hash(gx, gz, seed);
  const v10 = hash(gx+1, gz, seed);
  const v01 = hash(gx, gz+1, seed);
  const v11 = hash(gx+1, gz+1, seed);
  const a = lerp(v00, v10, u);
  const b = lerp(v01, v11, u);
  return lerp(a, b, v)*2 - 1;
}

// fBm
function fbm2D(x, z, oct=5, baseScale=180, seed=1337){
  let amp=1, freq=1, sum=0, norm=0;
  for(let i=0;i<oct;i++){
    sum += amp * valueNoise2D(x*freq, z*freq, baseScale, seed + i*101);
    norm += amp;
    amp *= 0.5;
    freq *= 2.0;
  }
  return sum / norm;
}

/*** ---------- World config ---------- ***/
const CHUNK_SIZE = 160;
const CHUNK_RES  = 60;
const VIEW_RADIUS = 3;
const PLAYER_HEIGHT = 1.7;
const GRAVITY = 28;
const MOVE_ACCEL = 65;
const MOVE_DAMP = 10;
const JUMP_VEL = 9.6;

const TERRAIN_AMPLITUDE = 22;
const SEA_LEVEL = 0.0;

const ITEM_PER_CHUNK = 14;
const PICKUP_DISTANCE = 2.0;

const DAY_MINUTES = 4;

const FLOWERS_PER_CHUNK = 70;

/*** ---------- Three.js setup ---------- ***/
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x88c6ff);
scene.fog = new THREE.FogExp2(0x88c6ff, 0.002);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1200);
camera.position.set(0, PLAYER_HEIGHT + 2, 0);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new PointerLockControls(camera, renderer.domElement);

/*** ---------- Lights & sky ---------- ***/
const sun = new THREE.DirectionalLight(0xffffff, 1.0);
sun.position.set(100,200,80);
scene.add(sun);

const ambient = new THREE.AmbientLight(0xffffff, 0.35);
scene.add(ambient);

/*** ---------- Water plane ---------- ***/
const waterGeo = new THREE.PlaneGeometry(4000, 4000, 1, 1);
waterGeo.rotateX(-Math.PI/2);
const waterMat = new THREE.MeshStandardMaterial({
  color: 0x78a7ff, transparent:true, opacity:0.55, metalness:0.2, roughness:0.4
});
const water = new THREE.Mesh(waterGeo, waterMat);
water.position.y = SEA_LEVEL - 0.15;
scene.add(water);

/*** ---------- Terrain generation ---------- ***/
// Height function
function heightAt(x, z){
  const h = fbm2D(x, z, 5, 220, 2025) * TERRAIN_AMPLITUDE
          + fbm2D(x+5000, z-8000, 3, 60, 9001) * 5;
  const ridge = Math.abs(fbm2D(x-12000, z+11111, 3, 300, 7777));
  return h + ridge*8 - 2;
}

// Biome tint color (multiplies final albedo later)
function colorFor(x, y, z){
  const b = fbm2D(x+25000, z-25000, 4, 300, 4040)*0.5 + 0.5;
  let col = new THREE.Color();
  if (y < SEA_LEVEL + 0.5){
    col.setRGB(0.05, 0.18, 0.28);
  } else if (b < 0.33){
    col.setRGB(0.76, 0.68, 0.42);  // sandy
  } else if (b < 0.66){
    col.setRGB(0.32, 0.56, 0.26);  // grassy
  } else {
    col.setRGB(0.42, 0.62, 0.42);  // alpine
  }
  const snow = smoothstep((y - 14) / 10);
  col.lerp(new THREE.Color(0.95,0.97,1.0), clamp(snow,0,1));
  return col;
}

/*** ---------- Textures (grass + procedural dirt/rock) ---------- ***/
const TEX_METERS = 4; // 1 tile per 4 meters
const GRASS_PATH = 'assets/grass.png'; // <- your seamless PNG
const DIRT_PATH  = null;               // e.g. 'assets/dirt.png' or keep null for procedural
const ROCK_PATH  = null;               // e.g. 'assets/rock.png' or keep null for procedural

const loader = new THREE.TextureLoader();

function makeDirtTexture(size=256){
  const c = document.createElement('canvas'); c.width=c.height=size;
  const g = c.getContext('2d');
  g.fillStyle = '#6e553b'; g.fillRect(0,0,size,size);
  for(let i=0;i<2000;i++){
    const x=Math.random()*size, y=Math.random()*size, r=Math.random()*1.6+0.2;
    g.fillStyle = Math.random()<0.5?'rgba(70,50,30,0.25)':'rgba(160,130,100,0.18)';
    g.beginPath(); g.arc(x,y,r,0,6.283); g.fill();
  }
  const tex = new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.colorSpace=THREE.SRGBColorSpace; return tex;
}
function makeRockTexture(size=256){
  const c = document.createElement('canvas'); c.width=c.height=size;
  const g = c.getContext('2d');
  g.fillStyle = '#808993'; g.fillRect(0,0,size,size);
  for(let i=0;i<1400;i++){
    const x=Math.random()*size, y=Math.random()*size;
    const w=Math.random()*3+0.5, h=Math.random()*1.5+0.3;
    g.fillStyle = Math.random()<0.5?'rgba(60,66,72,0.28)':'rgba(220,230,240,0.14)';
    g.beginPath(); g.ellipse(x,y,w,h,Math.random()*Math.PI,0,6.283); g.fill();
  }
  const tex = new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.colorSpace=THREE.SRGBColorSpace; return tex;
}

function loadTexOr(makeFn, path){
  if (!path) return makeFn();
  const t = loader.load(path, ()=>{ t.needsUpdate=true; });
  t.wrapS = t.wrapT = THREE.RepeatWrapping;
  t.colorSpace = THREE.SRGBColorSpace;
  return t;
}

const grassTex = loader.load(GRASS_PATH, ()=>{ grassTex.needsUpdate = true; });
grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
grassTex.colorSpace = THREE.SRGBColorSpace;

const dirtTex = loadTexOr(makeDirtTexture, DIRT_PATH);
const rockTex = loadTexOr(makeRockTexture, ROCK_PATH);

const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
[grassTex, dirtTex, rockTex].forEach(t=> t.anisotropy = maxAniso);

/*** ---------- Terrain material with triplanar + slope blend (FIXED) ---------- ***/
const terrainMat = new THREE.MeshStandardMaterial({
  vertexColors:true,
  flatShading:true,
  metalness:0.0,
  roughness:0.95,
  map: grassTex // keep 'map' so <map_fragment> exists
});

terrainMat.onBeforeCompile = (shader)=>{
  // uniforms
  shader.uniforms.grassMap   = { value: grassTex };
  shader.uniforms.dirtMap    = { value: dirtTex };
  shader.uniforms.rockMap    = { value: rockTex };
  shader.uniforms.tileScale  = { value: 1.0 / TEX_METERS };
  shader.uniforms.slopeStart = { value: 0.35 };
  shader.uniforms.slopeEnd   = { value: 0.80 };
  shader.uniforms.triSharp   = { value: 4.0 };

  // varyings in VERTEX
  shader.vertexShader = shader.vertexShader
    .replace('#include <common>', `
      #include <common>
      varying vec3 vWorldPos;
      varying vec3 vWorldNormal;
    `)
    .replace('#include <beginnormal_vertex>', `
      #include <beginnormal_vertex>
      vWorldNormal = normalize( mat3( modelMatrix ) * objectNormal );
    `)
    .replace('#include <begin_vertex>', `
      #include <begin_vertex>
      vWorldPos = (modelMatrix * vec4( transformed, 1.0 )).xyz;
    `);

  // declare uniforms + varyings in FRAGMENT, replace map block
  shader.fragmentShader = shader.fragmentShader
    .replace('#include <common>', `
      #include <common>
      varying vec3 vWorldPos;
      varying vec3 vWorldNormal;
      uniform sampler2D grassMap;
      uniform sampler2D dirtMap;
      uniform sampler2D rockMap;
      uniform float tileScale;
      uniform float slopeStart;
      uniform float slopeEnd;
      uniform float triSharp;

      vec3 triSampleTex(sampler2D tex, vec3 axisWeights, vec3 worldPos){
        vec2 uvX = worldPos.zy * tileScale; // project on YZ
        vec2 uvY = worldPos.xz * tileScale; // project on XZ (top)
        vec2 uvZ = worldPos.xy * tileScale; // project on XY
        vec4 tx = mapTexelToLinear( texture2D(tex, uvX) );
        vec4 ty = mapTexelToLinear( texture2D(tex, uvY) );
        vec4 tz = mapTexelToLinear( texture2D(tex, uvZ) );
        return tx.rgb * axisWeights.x + ty.rgb * axisWeights.y + tz.rgb * axisWeights.z;
      }
    `)
    .replace('#include <map_fragment>', `
      // --- Triplanar sampling with slope-based blending ---
      vec3 n = normalize( vWorldNormal );
      vec3 aw = pow( abs(n), vec3(triSharp) );
      aw /= (aw.x + aw.y + aw.z + 1e-5);

      vec3 grass = triSampleTex(grassMap, aw, vWorldPos);
      vec3 dirt  = triSampleTex(dirtMap,  aw, vWorldPos);
      vec3 rock  = triSampleTex(rockMap,  aw, vWorldPos);

      float slope = clamp(1.0 - abs(n.y), 0.0, 1.0);
      float wg = 1.0 - smoothstep(slopeStart*0.8, slopeStart, slope);
      float wd = smoothstep(slopeStart*0.6, slopeEnd*0.9, slope) * (1.0 - smoothstep(slopeEnd*0.9, slopeEnd, slope));
      float wr = smoothstep(slopeEnd*0.9, slopeEnd, slope);

      float wsum = wg + wd + wr + 1e-5;
      vec3 baseTex = (grass*wg + dirt*wd + rock*wr) / wsum;

      // Hand off to color/tone mapping; vertex color tint applies later in <color_fragment>
      diffuseColor.rgb = baseTex;
    `);
};

/*** ---------- Chunks + pickups + flowers ---------- ***/
const chunkMap = new Map();   // key -> mesh
const itemsMap = new Map();   // key -> pickups array
const decoMap  = new Map();   // key -> [instanced meshes]

function keyFor(cx, cz){ return `${cx},${cz}`; }

function buildChunk(cx, cz){
  const x0 = cx * CHUNK_SIZE;
  const z0 = cz * CHUNK_SIZE;

  const geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, CHUNK_RES, CHUNK_RES);
  geo.rotateX(-Math.PI/2);

  const pos = geo.attributes.position;
  const colors = new Float32Array((CHUNK_RES+1)*(CHUNK_RES+1)*3);

  for (let i=0; i<pos.count; i++){
    const vx = pos.getX(i) + x0;
    const vz = pos.getZ(i) + z0;
    const y  = heightAt(vx, vz);
    pos.setY(i, y);

    const col = colorFor(vx, y, vz);
    colors[i*3+0] = col.r; colors[i*3+1] = col.g; colors[i*3+2] = col.b;
  }
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geo.computeVertexNormals();

  const mesh = new THREE.Mesh(geo, terrainMat);
  mesh.frustumCulled = true;
  scene.add(mesh);

  const items = spawnItemsInChunk(x0, z0);
  itemsMap.set(keyFor(cx,cz), items);

  const flowers = scatterFlowersInChunk(x0, z0);
  decoMap.set(keyFor(cx,cz), flowers);

  return mesh;
}

function removeChunk(cx, cz){
  const k = keyFor(cx,cz);
  const m = chunkMap.get(k);
  if (m){
    scene.remove(m);
    m.geometry.dispose();
    chunkMap.delete(k);
  }
  const items = itemsMap.get(k);
  if (items){
    for (const it of items){
      scene.remove(it.mesh);
      if (it.mesh.geometry) it.mesh.geometry.dispose();
      if (it.mesh.material) it.mesh.material.dispose();
    }
    itemsMap.delete(k);
  }
  const decos = decoMap.get(k);
  if (decos){
    for (const d of decos){
      scene.remove(d);
      d.geometry.dispose();
      d.material.dispose();
    }
    decoMap.delete(k);
  }
}

function ensureChunksAround(px, pz){
  const ccx = Math.floor(px / CHUNK_SIZE);
  const ccz = Math.floor(pz / CHUNK_SIZE);
  const wanted = new Set();

  for (let dz=-VIEW_RADIUS; dz<=VIEW_RADIUS; dz++){
    for (let dx=-VIEW_RADIUS; dx<=VIEW_RADIUS; dx++){
      const cx = ccx + dx, cz = ccz + dz;
      const k = keyFor(cx,cz);
      wanted.add(k);
      if (!chunkMap.has(k)){
        const m = buildChunk(cx, cz);
        chunkMap.set(k, m);
        m.position.set(cx*CHUNK_SIZE, 0, cz*CHUNK_SIZE);
      }
    }
  }
  for (const k of chunkMap.keys()){
    if (!wanted.has(k)){
      const [cx, cz] = k.split(',').map(Number);
      removeChunk(cx, cz);
    }
  }
}

/*** ---------- Pickups & inventory ---------- ***/
const c_stick = document.getElementById('c_stick');
const c_rock  = document.getElementById('c_rock');
const c_berry = document.getElementById('c_berry');

const inventory = { stick:0, rock:0, berry:0 };
function updateInventoryUI(){
  c_stick.textContent = inventory.stick;
  c_rock.textContent  = inventory.rock;
  c_berry.textContent = inventory.berry;
}

function randInChunk(x0, z0){
  return [
    x0 + (Math.random()*2-1) * (CHUNK_SIZE*0.5-4),
    z0 + (Math.random()*2-1) * (CHUNK_SIZE*0.5-4)
  ];
}

function makePickupMesh(type){
  if (type === 'rock'){
    const g = new THREE.IcosahedronGeometry(0.3, 0);
    const m = new THREE.MeshStandardMaterial({ color:0x888888, roughness:1.0, metalness:0.0 });
    return new THREE.Mesh(g,m);
  }
  if (type === 'stick'){
    const g = new THREE.CylinderGeometry(0.06, 0.06, 0.9, 6);
    const m = new THREE.MeshStandardMaterial({ color:0x6b4e2e, roughness:0.9 });
    const mesh = new THREE.Mesh(g,m);
    mesh.rotation.z = (Math.random()*0.6-0.3); mesh.rotation.y = Math.random()*Math.PI;
    return mesh;
  }
  // berry bush
  const group = new THREE.Group();
  const base = new THREE.SphereGeometry(0.45, 12, 8, 0, Math.PI*2, 0, Math.PI/2);
  const bm = new THREE.MeshStandardMaterial({ color:0x2f6f2f, roughness:1.0 });
  const bush = new THREE.Mesh(base, bm); group.add(bush);
  for (let i=0;i<5;i++){
    const s = new THREE.Mesh(new THREE.SphereGeometry(0.08, 10, 8), new THREE.MeshStandardMaterial({ color:0xa11c3f, roughness:.7 }));
    s.position.set((Math.random()-0.5)*0.6, 0.2+Math.random()*0.2, (Math.random()-0.5)*0.6);
    group.add(s);
  }
  group.userData.isGroup = true;
  return group;
}

function spawnItemsInChunk(x0, z0){
  const arr = [];
  const n = Math.max(6, Math.floor(ITEM_PER_CHUNK * (Math.random()*0.6+0.7)));
  for (let i=0;i<n;i++){
    const type = Math.random()<0.38?'stick': (Math.random()<0.55?'rock':'berry');
    const [x,z] = randInChunk(x0, z0);
    const y = heightAt(x,z);
    if (y < SEA_LEVEL + 0.2) continue;
    const mesh = makePickupMesh(type);
    mesh.position.set(x, y + (type==='berry'?0.02:0.05), z);
    scene.add(mesh);
    arr.push({ type, mesh, x, y, z, taken:false });
  }
  return arr;
}

/*** ---------- Flowers (instanced) ---------- ***/
function approxSlope(x, z){
  const e = 0.6;
  const hL = heightAt(x-e, z), hR = heightAt(x+e, z);
  const hD = heightAt(x, z-e), hU = heightAt(x, z+e);
  const nx = hL - hR, nz = hD - hU, ny = 2*e;
  const len = Math.sqrt(nx*nx + ny*ny + nz*nz);
  const nyN = ny/len;
  return 1 - Math.abs(nyN); // ~0 flat .. 1 steep
}
function scatterFlowersInChunk(x0, z0){
  const count = Math.floor(FLOWERS_PER_CHUNK * (Math.random()*0.6+0.7));

  const stemGeo  = new THREE.CylinderGeometry(0.02, 0.02, 0.25, 6);
  const stemMat1 = new THREE.MeshStandardMaterial({ color:0x2e7d32, roughness:0.9 });
  const bloomGeo = new THREE.IcosahedronGeometry(0.06, 0);
  const bloomMatPink = new THREE.MeshStandardMaterial({ color:0xffb1d6, roughness:0.7 });
  const bloomMatWhite= new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.7 });

  const stems = new THREE.InstancedMesh(stemGeo, stemMat1, count);
  const bloomsPink  = new THREE.InstancedMesh(bloomGeo, bloomMatPink, Math.floor(count*0.6));
  const bloomsWhite = new THREE.InstancedMesh(bloomGeo, bloomMatWhite, count - bloomsPink.count);

  const m = new THREE.Matrix4();
  let i=0, ip=0, iw=0, tries=0;
  while (i < count && tries < count*6){
    tries++;
    const [x,z] = randInChunk(x0, z0);
    const y = heightAt(x,z);
    if (y < SEA_LEVEL+0.2) continue;
    if (y > 18.0) continue;              // avoid snowy tops
    if (approxSlope(x,z) > 0.25) continue; // gentle ground only

    // stem
    m.identity().setPosition(x, y+0.125, z);
    stems.setMatrixAt(i, m);

    // bloom color
    m.identity().setPosition(x, y+0.25, z);
    if (Math.random()<0.6 && ip < bloomsPink.count){
      bloomsPink.setMatrixAt(ip++, m);
    } else if (iw < bloomsWhite.count){
      bloomsWhite.setMatrixAt(iw++, m);
    } else if (ip < bloomsPink.count){
      bloomsPink.setMatrixAt(ip++, m);
    } else {
      bloomsWhite.setMatrixAt(iw++, m);
    }
    i++;
  }
  stems.instanceMatrix.needsUpdate = true;
  bloomsPink.instanceMatrix.needsUpdate = true;
  bloomsWhite.instanceMatrix.needsUpdate = true;

  scene.add(stems, bloomsPink, bloomsWhite);
  return [stems, bloomsPink, bloomsWhite];
}

/*** ---------- Player movement & systems ---------- ***/
const keys = new Set();
addEventListener('keydown', e=>{ if (e.code === 'Space') e.preventDefault(); keys.add(e.code); });
addEventListener('keyup', e=>keys.delete(e.code));

const vel = new THREE.Vector3(0,0,0);
let canJump = false;

/*** ---------- Weather (rain) ---------- ***/
const MAX_RAIN = 2400;
const rainGeo = new THREE.BufferGeometry();
rainGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(MAX_RAIN*3), 3));
const rainMat = new THREE.PointsMaterial({ size:0.08, transparent:true, opacity:0.8, depthWrite:false });
const rain = new THREE.Points(rainGeo, rainMat);
rain.visible = false;
scene.add(rain);
let raining = false;
function toggleRain(on){
  raining = on; rain.visible = on;
  if (on){
    const arr = rainGeo.attributes.position.array;
    for (let i=0;i<MAX_RAIN;i++){
      arr[i*3+0] = camera.position.x + (Math.random()*2-1)*40;
      arr[i*3+1] = camera.position.y + 20 + Math.random()*25;
      arr[i*3+2] = camera.position.z + (Math.random()*2-1)*40;
    }
    rainGeo.attributes.position.needsUpdate = true;
  }
}
let weatherTimer = 0;
function updateWeather(dt){
  weatherTimer -= dt;
  if (weatherTimer <= 0){
    if (Math.random() < 0.3) toggleRain(!raining);
    weatherTimer = 20 + Math.random()*25;
  }
}

/*** ---------- Campfire ---------- ***/
function buildCampfireAt(x,z){
  const g = new THREE.CylinderGeometry(0.18, 0.18, 0.5, 6);
  const m = new THREE.MeshStandardMaterial({ color:0x5a3d27, roughness:0.95 });
  const log1 = new THREE.Mesh(g,m), log2 = log1.clone(), log3 = log1.clone();
  const y = heightAt(x,z) + 0.25;
  log1.position.set(x,y,z); log2.position.set(x,y,z); log3.position.set(x,y,z);
  log1.rotation.z = 0.4; log2.rotation.z = -0.4; log3.rotation.x = 0.6;
  scene.add(log1,log2,log3);

  const flame = new THREE.Mesh(new THREE.SphereGeometry(0.22, 16, 12),
    new THREE.MeshBasicMaterial({ color:0xffb74d }));
  flame.position.set(x, y+0.1, z); scene.add(flame);

  const glow = new THREE.PointLight(0xffa040, 1.6, 15, 1.5);
  glow.position.set(x, y+0.3, z); scene.add(glow);

  const baseI = glow.intensity;
  campfires.push({ glow, flame, t: Math.random()*100, baseI });
}
const campfires = [];
function updateCampfires(dt){
  for (const c of campfires){
    c.t += dt*8;
    c.glow.intensity = c.baseI * (0.75 + Math.sin(c.t)*0.25 + Math.random()*0.08);
    const k = 0.8 + Math.random()*0.2;
    c.flame.scale.setScalar(k);
  }
}

/*** ---------- UI ---------- ***/
const help = document.getElementById('help');
const lockBtn = document.getElementById('lockBtn');
lockBtn.onclick = ()=>controls.lock();
controls.addEventListener('lock', ()=>{ help.style.display='none'; });
controls.addEventListener('unlock', ()=>{ help.style.display=''; });

const invPanel = document.getElementById('inventory');
let inventoryOpen = false;
addEventListener('keydown', (e)=>{
  if (e.code === 'KeyI'){
    inventoryOpen = !inventoryOpen;
    invPanel.style.display = inventoryOpen? 'block' : 'none';
  }
});

const interact = document.getElementById('interact');
function showInteract(msg){ interact.textContent = msg; interact.style.opacity = 1; }
function hideInteract(){ interact.style.opacity = 0; }
const statusEl = document.getElementById('status');

/*** ---------- Game loop ---------- ***/
const clock = new THREE.Clock();
let chunkCheckTimer = 0;

// Day cycle
let timeOfDay = 8.0;
function updateDayNight(dt){
  const minutesPerSec = (24 / (DAY_MINUTES*60));
  timeOfDay = (timeOfDay + dt * minutesPerSec * 60) % 24;

  const t = (timeOfDay / 24) * Math.PI*2;
  const elev = Math.sin(t), azim = Math.cos(t);
  sun.position.set(azim*200, Math.max(10, elev*220 + 120), elev*120);
  sun.intensity = clamp(0.1 + Math.max(0, elev)*0.9, 0.1, 1.2);
  ambient.intensity = 0.20 + Math.max(0, elev)*0.25;

  const dayCol = new THREE.Color(0x88c6ff);
  const duskCol = new THREE.Color(0xf5b080);
  const nightCol = new THREE.Color(0x0b1020);
  let sky = dayCol.clone();
  if (elev < 0.1){
    const k = clamp((0.1 - elev)/0.6, 0, 1); sky.lerp(nightCol, k);
  } else if (elev < 0.3){
    const k = clamp((0.3 - elev)/0.2, 0, 1); sky.lerp(duskCol, k);
  }
  if (raining) sky.lerp(new THREE.Color(0x6a8bb3), 0.35);
  scene.background.copy(sky); scene.fog.color.copy(sky);
}

// Movement & collision
function updatePlayer(dt){
  if (!controls.isLocked) return;
  const forward = new THREE.Vector3(), right = new THREE.Vector3();
  camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
  right.crossVectors(forward, new THREE.Vector3(0,1,0)).multiplyScalar(-1).normalize();

  const acc = new THREE.Vector3();
  if (keys.has('KeyW')) acc.add(forward);
  if (keys.has('KeyS')) acc.add(forward.clone().multiplyScalar(-1));
  if (keys.has('KeyA')) acc.add(right.clone().multiplyScalar(-1));
  if (keys.has('KeyD')) acc.add(right);
  if (acc.lengthSq()>0) acc.normalize().multiplyScalar(MOVE_ACCEL);

  vel.x += acc.x * dt; vel.z += acc.z * dt;
  vel.x -= vel.x * MOVE_DAMP * dt; vel.z -= vel.z * MOVE_DAMP * dt;
  vel.y -= GRAVITY * dt;

  if (keys.has('Space') && canJump){ vel.y = JUMP_VEL; canJump = false; }

  const pos = camera.position;
  pos.x += vel.x * dt; pos.z += vel.z * dt; pos.y += vel.y * dt;

  const groundY = heightAt(pos.x, pos.z) + PLAYER_HEIGHT;
  if (pos.y < groundY){ pos.y = groundY; vel.y = 0; canJump = true; }
}

// Pickups + building
let pickupCooldown = 0;
addEventListener('keydown', (e)=>{
  if (!controls.isLocked) return;
  if (e.code === 'KeyE'){ tryPickup(); }
  else if (e.code === 'KeyB'){
    if (inventory.stick >= 3 && inventory.rock >= 1){
      inventory.stick -= 3; inventory.rock -= 1; updateInventoryUI();
      buildCampfireAt(camera.position.x, camera.position.z);
    }
  }
});

function tryPickup(){
  if (pickupCooldown > 0) return;
  const n = nearestPickup(camera.position.x, camera.position.y, camera.position.z);
  if (n && n.dist <= PICKUP_DISTANCE){
    const it = n.item; it.taken = true; scene.remove(it.mesh);
    inventory[it.type] = (inventory[it.type]||0) + 1; updateInventoryUI();
    pickupCooldown = 0.2;
  }
}

function nearestPickup(px, py, pz){
  let best=null, bestD=1e9;
  for (const items of itemsMap.values()){
    for (const it of items){
      if (it.taken) continue;
      const dx = it.x - px, dy = (it.y+0.3) - py, dz = it.z - pz;
      const d2 = dx*dx + dy*dy + dz*dz;
      if (d2 < bestD){ bestD = d2; best = it; }
    }
  }
  return best ? { item:best, dist: Math.sqrt(bestD) } : null;
}

/*** ---------- Resize ---------- ***/
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/*** ---------- Start ---------- ***/
updateInventoryUI();
let rainFallSpeed = 18;

function animate(){
  const dt = clamp(clock.getDelta(), 0, 0.05);

  chunkCheckTimer -= dt;
  if (chunkCheckTimer <= 0){
    ensureChunksAround(camera.position.x, camera.position.z);
    chunkCheckTimer = 0.25;
  }

  updateDayNight(dt);
  updateWeather(dt);
  updateCampfires(dt);

  if (raining){
    const arr = rainGeo.attributes.position.array;
    for (let i=0;i<MAX_RAIN;i++){
      arr[i*3+1] -= rainFallSpeed * dt;
      if (arr[i*3+1] < heightAt(arr[i*3+0], arr[i*3+2]) + 0.2){
        arr[i*3+0] = camera.position.x + (Math.random()*2-1)*40;
        arr[i*3+1] = camera.position.y + 20 + Math.random()*25;
        arr[i*3+2] = camera.position.z + (Math.random()*2-1)*40;
      }
    }
    rainGeo.attributes.position.needsUpdate = true;
  }

  updatePlayer(dt);
  if (pickupCooldown>0) pickupCooldown -= dt;

  const n = nearestPickup(camera.position.x, camera.position.y, camera.position.z);
  if (controls.isLocked && n && n.dist <= PICKUP_DISTANCE){
    const label = n.item.type.charAt(0).toUpperCase() + n.item.type.slice(1);
    showInteract(`E â€” Pick up ${label}`);
  } else {
    hideInteract();
  }

  statusEl.textContent =
    `time ${timeOfDay.toFixed(1)}h | weather ${raining?'rain':'clear'} | ` +
    `x ${camera.position.x.toFixed(1)} z ${camera.position.z.toFixed(1)}`;

  water.material.opacity = raining? 0.6 : 0.55;
  water.material.roughness = raining? 0.55 : 0.4;

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

camera.position.set(8, PLAYER_HEIGHT+2, 8);
ensureChunksAround(camera.position.x, camera.position.z);
</script>
</body>
</html>
