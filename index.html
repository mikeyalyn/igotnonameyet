<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Plushlands — Reflections + Wind Sway (Fixed)</title>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
  }
}
</script>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#000; font-family:system-ui, sans-serif; }
  #ui { position: fixed; inset: 0; pointer-events: none; color:#fff; text-shadow: 0 1px 2px rgba(0,0,0,.7); }
  #hud { position:absolute; left:12px; top:12px; pointer-events:none; font-size:14px; line-height:1.3;
         background: rgba(0,0,0,0.35); padding:8px 10px; border-radius:10px; backdrop-filter: blur(4px); }
  #interact { position:absolute; left:50%; bottom:18%; transform: translateX(-50%); pointer-events:none; font-size:16px;
              background: rgba(0,0,0,0.4); padding:8px 12px; border-radius:999px; opacity:0; transition: opacity .15s; }
  #crosshair { position:absolute; left:50%; top:50%; width:12px; height:12px; transform:translate(-50%,-50%);
               border-radius:50%; box-shadow: 0 0 0 2px rgba(255,255,255,.8); opacity:.7; pointer-events:none; }
  #help { position:absolute; left:50%; top:40%; transform:translateX(-50%); text-align:center; max-width:640px; padding:20px;
          background: rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.15); border-radius:16px; pointer-events:auto; }
  #help h1 { margin:0 0 10px; font-size:28px; }
  #help p { margin:6px 0; opacity:.95 }
  #lockBtn { display:inline-block; margin-top:10px; padding:10px 16px; border-radius:999px; background:#73b8ff; color:#002;
             text-shadow:none; font-weight:700; cursor:pointer; pointer-events:auto; }
  #inventory { position: absolute; right:12px; top:12px; width:260px; pointer-events:auto; display:none;
               background: rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:12px; }
  #inventory h3 { margin:0 0 8px; }
  .grid { display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; }
  .slot { background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:8px; min-height:60px; }
  .label { font-size:12px; opacity:.85; }
  .count { font-size:18px; font-weight:700; }
  #notice { position:absolute; right:12px; bottom:12px; background: rgba(0,0,0,.5);
            border:1px solid rgba(255,255,255,.15); border-radius:12px; padding:8px 12px; font-size:13px; }
</style>
</head>
<body>
<div id="ui">
  <div id="hud">
    <div><b>Plushlands</b> • WASD move, SPACE jump, I inventory, E pick up, B build campfire</div>
    <div id="status">time … | weather … | x … z …</div>
  </div>
  <div id="interact">E — Pick up</div>
  <div id="crosshair"></div>
  <div id="help">
    <h1>Click to enter the world :3</h1>
    <p>Reflective water, wind sway, triplanar terrain (shader fix).</p>
    <div id="lockBtn">Start</div>
    <p style="opacity:.8;margin-top:10px">Tip: open inventory with <b>I</b></p>
  </div>

  <div id="inventory">
    <h3>Inventory</h3>
    <div class="grid">
      <div class="slot"><div class="label">Sticks</div><div id="c_stick" class="count">0</div></div>
      <div class="slot"><div class="label">Rocks</div><div id="c_rock" class="count">0</div></div>
      <div class="slot"><div class="label">Berries</div><div id="c_berry" class="count">0</div></div>
    </div>
    <div style="margin-top:10px; font-size:12px; opacity:.9">
      Build campfire: <b>3 sticks + 1 rock</b> then press <b>B</b>
    </div>
  </div>

  <div id="notice">v0.4-fixed — self-contained assets</div>
</div>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
import { Water } from 'three/addons/objects/Water2.js';

/*** ---------- Helpers ---------- ***/
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a,b,t) => a + (b-a)*t;
const smoothstep = (t)=>t*t*(3-2*t);
const smoother = (t)=>t*t*t*(t*(6*t-15)+10);
function hash(ix, iz, seed=1337){
  let x = Math.imul(ix ^ seed, 374761393) ^ Math.imul(iz + 0x9e3779b9, 668265263);
  x = (x ^ (x >>> 13)) >>> 0; x = Math.imul(x, 1274126177) >>> 0;
  return (x >>> 8) / 16777216;
}
function valueNoise2D(x, z, S=64, seed=1337){
  const gx = Math.floor(x / S), gz = Math.floor(z / S);
  const fx = (x / S) - gx, fz = (z / S) - gz;
  const u = smoother(fx), v = smoother(fz);
  const v00 = hash(gx, gz, seed), v10 = hash(gx+1, gz, seed);
  const v01 = hash(gx, gz+1, seed), v11 = hash(gx+1, gz+1, seed);
  const a = lerp(v00, v10, u), b = lerp(v01, v11, u);
  return lerp(a, b, v)*2 - 1;
}
function fbm2D(x, z, oct=5, baseScale=180, seed=1337){
  let amp=1, freq=1, sum=0, norm=0;
  for(let i=0;i<oct;i++){ sum += amp * valueNoise2D(x*freq, z*freq, baseScale, seed + i*101); norm += amp; amp *= 0.5; freq *= 2.0; }
  return sum / norm;
}

/*** ---------- World config ---------- ***/
const CHUNK_SIZE = 160, CHUNK_RES = 60, VIEW_RADIUS = 3;
const PLAYER_HEIGHT = 1.7, GRAVITY = 28, MOVE_ACCEL = 65, MOVE_DAMP = 10, JUMP_VEL = 9.6;
const TERRAIN_AMPLITUDE = 22, SEA_LEVEL = 0.0;
const ITEM_PER_CHUNK = 14, PICKUP_DISTANCE = 2.0;
const DAY_MINUTES = 4;
const FLOWERS_PER_CHUNK = 70;

/*** ---------- Three.js setup ---------- ***/
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x88c6ff);
scene.fog = new THREE.FogExp2(0x88c6ff, 0.002);
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1200);
camera.position.set(0, PLAYER_HEIGHT + 2, 0);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);
const controls = new PointerLockControls(camera, renderer.domElement);

/*** ---------- Lights & sky ---------- ***/
const sun = new THREE.DirectionalLight(0xffffff, 1.0);
sun.position.set(100,200,80); scene.add(sun);
const ambient = new THREE.AmbientLight(0xffffff, 0.35); scene.add(ambient);

/*** ---------- Height / Biome ---------- ***/
function heightAt(x, z){
  const h = fbm2D(x, z, 5, 220, 2025) * TERRAIN_AMPLITUDE
          + fbm2D(x+5000, z-8000, 3, 60, 9001) * 5;
  const ridge = Math.abs(fbm2D(x-12000, z+11111, 3, 300, 7777));
  return h + ridge*8 - 2;
}
function colorFor(x, y, z){
  const b = fbm2D(x+25000, z-25000, 4, 300, 4040)*0.5 + 0.5;
  let col = new THREE.Color();
  if (y < SEA_LEVEL + 0.5){ col.setRGB(0.05, 0.18, 0.28);
  } else if (b < 0.33){ col.setRGB(0.76, 0.68, 0.42);
  } else if (b < 0.66){ col.setRGB(0.32, 0.56, 0.26);
  } else { col.setRGB(0.42, 0.62, 0.42); }
  const snow = smoothstep((y - 14) / 10); col.lerp(new THREE.Color(0.95,0.97,1.0), clamp(snow,0,1));
  return col;
}

/*** ---------- Textures (grass + procedural dirt/rock) ---------- ***/
const TEX_METERS = 4;
const GRASS_PATH = 'assets/grass.png';
const loader = new THREE.TextureLoader();
function makeDirtTexture(){
  const c = document.createElement('canvas'); c.width=c.height=256; const g = c.getContext('2d');
  g.fillStyle = '#6e553b'; g.fillRect(0,0,256,256);
  for(let i=0;i<2000;i++){ const x=Math.random()*256,y=Math.random()*256,r=Math.random()*1.6+0.2;
    g.fillStyle = Math.random()<0.5?'rgba(70,50,30,0.25)':'rgba(160,130,100,0.18)'; g.beginPath(); g.arc(x,y,r,0,6.283); g.fill(); }
  const t = new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.colorSpace=THREE.SRGBColorSpace; return t;
}
function makeRockTexture(){
  const c = document.createElement('canvas'); c.width=c.height=256; const g = c.getContext('2d');
  g.fillStyle = '#808993'; g.fillRect(0,0,256,256);
  for(let i=0;i<1400;i++){ const x=Math.random()*256,y=Math.random()*256,w=Math.random()*3+0.5,h=Math.random()*1.5+0.3;
    g.fillStyle = Math.random()<0.5?'rgba(60,66,72,0.28)':'rgba(220,230,240,0.14)'; g.beginPath(); g.ellipse(x,y,w,h,Math.random()*3.1415,0,6.283); g.fill(); }
  const t = new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.colorSpace=THREE.SRGBColorSpace; return t;
}
const grassTex = loader.load(GRASS_PATH, ()=>{ grassTex.needsUpdate = true; });
grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping; grassTex.colorSpace = THREE.SRGBColorSpace;
const dirtTex  = makeDirtTexture();
const rockTex  = makeRockTexture();
const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
[grassTex,dirtTex,rockTex].forEach(t=> t.anisotropy = maxAniso);

/*** ---------- Terrain material (triplanar + slope blend, fixed) ---------- ***/
const terrainMat = new THREE.MeshStandardMaterial({ vertexColors:true, flatShading:true, metalness:0.0, roughness:0.95, map: grassTex });
terrainMat.onBeforeCompile = (shader)=>{
  shader.uniforms.grassMap   = { value: grassTex };
  shader.uniforms.dirtMap    = { value: dirtTex };
  shader.uniforms.rockMap    = { value: rockTex };
  shader.uniforms.tileScale  = { value: 1.0 / TEX_METERS };
  shader.uniforms.slopeStart = { value: 0.35 };
  shader.uniforms.slopeEnd   = { value: 0.80 };
  shader.uniforms.triSharp   = { value: 4.0 };

  shader.vertexShader = shader.vertexShader
    .replace('#include <common>', `
      #include <common>
      varying vec3 vWorldPos;
      varying vec3 vWorldNormal;
    `)
    .replace('#include <beginnormal_vertex>', `
      #include <beginnormal_vertex>
      vWorldNormal = normalize( mat3( modelMatrix ) * objectNormal );
    `)
    .replace('#include <begin_vertex>', `
      #include <begin_vertex>
      vWorldPos = (modelMatrix * vec4( transformed, 1.0 )).xyz;
    `);

  shader.fragmentShader = shader.fragmentShader
    .replace('#include <common>', `
      #include <common>
      varying vec3 vWorldPos;
      varying vec3 vWorldNormal;
      uniform sampler2D grassMap, dirtMap, rockMap;
      uniform float tileScale, slopeStart, slopeEnd, triSharp;
      vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
      vec3 triSampleTex(sampler2D tex, vec3 axisWeights, vec3 worldPos){
        vec2 uvX = worldPos.zy * tileScale; vec2 uvY = worldPos.xz * tileScale; vec2 uvZ = worldPos.xy * tileScale;
        vec3 tx = texture2D(tex, uvX).rgb; vec3 ty = texture2D(tex, uvY).rgb; vec3 tz = texture2D(tex, uvZ).rgb;
        return srgbToLinear(tx*axisWeights.x + ty*axisWeights.y + tz*axisWeights.z);
      }
    `)
    .replace('#include <map_fragment>', `
      vec3 n = normalize( vWorldNormal );
      vec3 aw = pow( abs(n), vec3(triSharp) );
      aw /= (aw.x + aw.y + aw.z + 1e-5);

      vec3 grass = triSampleTex(grassMap, aw, vWorldPos);
      vec3 dirt  = triSampleTex(dirtMap,  aw, vWorldPos);
      vec3 rock  = triSampleTex(rockMap,  aw, vWorldPos);

      float slope = clamp(1.0 - abs(n.y), 0.0, 1.0);
      float wg = 1.0 - smoothstep(slopeStart*0.8, slopeStart, slope);
      float wd = smoothstep(slopeStart*0.6, slopeEnd*0.9, slope) * (1.0 - smoothstep(slopeEnd*0.9, slopeEnd, slope));
      float wr = smoothstep(slopeEnd*0.9, slopeEnd, slope);

      float wsum = wg + wd + wr + 1e-5;
      vec3 baseTex = (grass*wg + dirt*wd + rock*wr) / wsum;
      diffuseColor.rgb = baseTex;
    `);
};
terrainMat.needsUpdate = true;

/*** ---------- Reflective water (local normal maps) ---------- ***/
const waterNormals0 = loader.load('assets/water/normal0.png', t => { t.wrapS=t.wrapT=THREE.RepeatWrapping; });
const waterNormals1 = loader.load('assets/water/normal1.png', t => { t.wrapS=t.wrapT=THREE.RepeatWrapping; });
const waterGeo = new THREE.PlaneGeometry(4000, 4000);
const water = new Water(waterGeo, {
  color: 0x76b6ff,
  scale: 1,
  flowDirection: new THREE.Vector2(0.6, 0.25),
  textureWidth: 1024, textureHeight: 1024,
  normalTexture0: waterNormals0,
  normalTexture1: waterNormals1
});
water.rotation.x = -Math.PI/2;
water.position.y = SEA_LEVEL - 0.05;
scene.add(water);

/*** ---------- Chunks / pickups / flowers ---------- ***/
const chunkMap = new Map(), itemsMap = new Map(), decoMap = new Map();
const keyFor = (cx,cz)=> `${cx},${cz}`;

function buildChunk(cx, cz){
  const x0 = cx*CHUNK_SIZE, z0 = cz*CHUNK_SIZE;
  const geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, CHUNK_RES, CHUNK_RES);
  geo.rotateX(-Math.PI/2);
  const pos = geo.attributes.position;
  const colors = new Float32Array((CHUNK_RES+1)*(CHUNK_RES+1)*3);
  for (let i=0;i<pos.count;i++){
    const vx = pos.getX(i)+x0, vz = pos.getZ(i)+z0, y = heightAt(vx, vz);
    pos.setY(i, y);
    const col = colorFor(vx, y, vz);
    colors[i*3+0]=col.r; colors[i*3+1]=col.g; colors[i*3+2]=col.b;
  }
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geo.computeVertexNormals();
  const mesh = new THREE.Mesh(geo, terrainMat);
  mesh.frustumCulled = true; scene.add(mesh);
  const items = spawnItemsInChunk(x0, z0); itemsMap.set(keyFor(cx,cz), items);
  const flowers = scatterFlowersInChunk(x0, z0); decoMap.set(keyFor(cx,cz), flowers);
  return mesh;
}
function removeChunk(cx, cz){
  const k = keyFor(cx,cz), m = chunkMap.get(k);
  if (m){ scene.remove(m); m.geometry.dispose(); chunkMap.delete(k); }
  const items = itemsMap.get(k);
  if (items){ for (const it of items){ scene.remove(it.mesh); it.mesh.geometry?.dispose(); it.mesh.material?.dispose(); } itemsMap.delete(k); }
  const decos = decoMap.get(k);
  if (decos){ for (const d of decos){ scene.remove(d); d.geometry.dispose(); d.material.dispose(); } decoMap.delete(k); }
}
function ensureChunksAround(px, pz){
  const ccx = Math.floor(px/CHUNK_SIZE), ccz = Math.floor(pz/CHUNK_SIZE);
  const wanted = new Set();
  for (let dz=-VIEW_RADIUS; dz<=VIEW_RADIUS; dz++){
    for (let dx=-VIEW_RADIUS; dx<=VIEW_RADIUS; dx++){
      const cx=ccx+dx, cz=ccz+dz, k=keyFor(cx,cz); wanted.add(k);
      if (!chunkMap.has(k)){ const m = buildChunk(cx, cz); chunkMap.set(k, m); m.position.set(cx*CHUNK_SIZE,0,cz*CHUNK_SIZE); }
    }
  }
  for (const k of chunkMap.keys()){ if (!wanted.has(k)){ const [cx,cz]=k.split(',').map(Number); removeChunk(cx,cz); } }
}

/*** ---------- Pickups & inventory ---------- ***/
const c_stick = document.getElementById('c_stick'), c_rock = document.getElementById('c_rock'), c_berry = document.getElementById('c_berry');
const inventory = { stick:0, rock:0, berry:0 };
function updateInventoryUI(){ c_stick.textContent=inventory.stick; c_rock.textContent=inventory.rock; c_berry.textContent=inventory.berry; }
function randInChunk(x0, z0){ return [ x0 + (Math.random()*2-1)*(CHUNK_SIZE*0.5-4), z0 + (Math.random()*2-1)*(CHUNK_SIZE*0.5-4) ]; }
function makePickupMesh(type){
  if (type==='rock'){ const g=new THREE.IcosahedronGeometry(0.3,0), m=new THREE.MeshStandardMaterial({color:0x888888,roughness:1,metalness:0}); return new THREE.Mesh(g,m); }
  if (type==='stick'){ const g=new THREE.CylinderGeometry(0.06,0.06,0.9,6), m=new THREE.MeshStandardMaterial({color:0x6b4e2e,roughness:0.9});
    const mesh=new THREE.Mesh(g,m); mesh.rotation.z=(Math.random()*0.6-0.3); mesh.rotation.y=Math.random()*Math.PI; return mesh; }
  const group=new THREE.Group(); const base=new THREE.SphereGeometry(0.45,12,8,0,Math.PI*2,0,Math.PI/2);
  const bm=new THREE.MeshStandardMaterial({color:0x2f6f2f,roughness:1}); const bush=new THREE.Mesh(base,bm); group.add(bush);
  for (let i=0;i<5;i++){ const s=new THREE.Mesh(new THREE.SphereGeometry(0.08,10,8), new THREE.MeshStandardMaterial({color:0xa11c3f,roughness:.7}));
    s.position.set((Math.random()-0.5)*0.6,0.2+Math.random()*0.2,(Math.random()-0.5)*0.6); group.add(s); }
  group.userData.isGroup=true; return group;
}
function spawnItemsInChunk(x0, z0){
  const arr=[]; const n=Math.max(6, Math.floor(ITEM_PER_CHUNK*(Math.random()*0.6+0.7)));
  for (let i=0;i<n;i++){
    const type = Math.random()<0.38?'stick': (Math.random()<0.55?'rock':'berry');
    const [x,z]=randInChunk(x0,z0); const y=heightAt(x,z); if (y<SEA_LEVEL+0.2) continue;
    const mesh=makePickupMesh(type); mesh.position.set(x,y+(type==='berry'?0.02:0.05),z); scene.add(mesh);
    arr.push({type,mesh,x,y,z,taken:false});
  }
  return arr;
}

/*** ---------- Wind-sway flowers (instanced) ---------- ***/
const SWAY_MATERIALS = [];
function swayify(mat, amp=0.06, speed=1.5){
  mat.onBeforeCompile = (shader)=>{
    shader.uniforms.uTime = {value: 0};
    shader.uniforms.uAmp = {value: amp};
    shader.uniforms.uSpeed = {value: speed};
    shader.vertexShader = shader.vertexShader
      .replace('#include <common>', `
        #include <common>
        uniform float uTime, uAmp, uSpeed;
      `)
      .replace('#include <begin_vertex>', `
        #include <begin_vertex>
        vec3 baseWorld = (modelMatrix * vec4(0.0,0.0,0.0,1.0)).xyz;
        float phase = fract(sin(dot(baseWorld.xz, vec2(12.9898,78.233))) * 43758.5453);
        float t = uTime * uSpeed + phase * 6.2831;
        float sway = sin(t) * uAmp * position.y;
        transformed.x += sway;
        transformed.z += cos(t*0.9) * (uAmp*0.5) * position.y;
      `);
    mat.userData.shader = shader;
  };
  SWAY_MATERIALS.push(mat);
}
const FLOWER = {
  stemGeo: new THREE.CylinderGeometry(0.02, 0.02, 0.25, 6),
  bloomGeo: new THREE.IcosahedronGeometry(0.06, 0),
  stemMat: new THREE.MeshStandardMaterial({ color:0x2e7d32, roughness:0.9 }),
  bloomPink: new THREE.MeshStandardMaterial({ color:0xffb1d6, roughness:0.7 }),
  bloomWhite: new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.7 })
};
swayify(FLOWER.stemMat, 0.06, 1.4);
swayify(FLOWER.bloomPink, 0.06, 1.4);
swayify(FLOWER.bloomWhite, 0.06, 1.4);

function approxSlope(x, z){
  const e=0.6; const hL=heightAt(x-e,z), hR=heightAt(x+e,z), hD=heightAt(x,z-e), hU=heightAt(x,z+e);
  const nx=hL-hR, nz=hD-hU, ny=2*e; const len=Math.sqrt(nx*nx+ny*ny+nz*nz); return 1 - Math.abs(ny/len);
}
function scatterFlowersInChunk(x0, z0){
  const count=Math.floor(FLOWERS_PER_CHUNK*(Math.random()*0.6+0.7));
  const stems=new THREE.InstancedMesh(FLOWER.stemGeo, FLOWER.stemMat, count);
  const bloomsPink = new THREE.InstancedMesh(FLOWER.bloomGeo, FLOWER.bloomPink, Math.floor(count*0.6));
  const bloomsWhite= new THREE.InstancedMesh(FLOWER.bloomGeo, FLOWER.bloomWhite, count - bloomsPink.count);
  const m=new THREE.Matrix4(); let i=0,ip=0,iw=0,tries=0;
  while (i<count && tries<count*6){
    tries++; const [x,z]=randInChunk(x0,z0); const y=heightAt(x,z);
    if (y<SEA_LEVEL+0.2 || y>18.0 || approxSlope(x,z)>0.25) continue;
    m.identity().setPosition(x, y+0.125, z); stems.setMatrixAt(i,m);
    m.identity().setPosition(x, y+0.25, z);
    if (Math.random()<0.6 && ip<bloomsPink.count) bloomsPink.setMatrixAt(ip++, m);
    else if (iw<bloomsWhite.count) bloomsWhite.setMatrixAt(iw++, m);
    else if (ip<bloomsPink.count) bloomsPink.setMatrixAt(ip++, m);
    else bloomsWhite.setMatrixAt(iw++, m);
    i++;
  }
  stems.instanceMatrix.needsUpdate = true; bloomsPink.instanceMatrix.needsUpdate = true; bloomsWhite.instanceMatrix.needsUpdate = true;
  scene.add(stems, bloomsPink, bloomsWhite);
  return [stems, bloomsPink, bloomsWhite];
}

/*** ---------- Player + UI ---------- ***/
const keys = new Set();
addEventListener('keydown', e=>{ if (e.code==='Space') e.preventDefault(); keys.add(e.code); });
addEventListener('keyup', e=>keys.delete(e.code));
const vel = new THREE.Vector3(0,0,0); let canJump = false;
const help = document.getElementById('help');
const lockBtn = document.getElementById('lockBtn');
lockBtn.onclick = ()=>controls.lock();
controls.addEventListener('lock', ()=>{ help.style.display='none'; });
controls.addEventListener('unlock', ()=>{ help.style.display=''; });
const invPanel = document.getElementById('inventory'); let inventoryOpen=false;
addEventListener('keydown', (e)=>{ if (e.code==='KeyI'){ inventoryOpen=!inventoryOpen; invPanel.style.display=inventoryOpen?'block':'none'; } });
const interact = document.getElementById('interact');
function showInteract(msg){ interact.textContent=msg; interact.style.opacity=1; }
function hideInteract(){ interact.style.opacity=0; }
const statusEl = document.getElementById('status');

/*** ---------- Weather (rain simple) ---------- ***/
const MAX_RAIN = 2400;
const rainGeo = new THREE.BufferGeometry();
rainGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(MAX_RAIN*3), 3));
const rainMat = new THREE.PointsMaterial({ size:0.08, transparent:true, opacity:0.8, depthWrite:false });
const rain = new THREE.Points(rainGeo, rainMat); rain.visible=false; scene.add(rain);
let raining=false, weatherTimer=0;
function toggleRain(on){
  raining=on; rain.visible=on;
  if (on){ const arr=rainGeo.attributes.position.array;
    for (let i=0;i<MAX_RAIN;i++){ arr[i*3+0]=camera.position.x+(Math.random()*2-1)*40; arr[i*3+1]=camera.position.y+20+Math.random()*25; arr[i*3+2]=camera.position.z+(Math.random()*2-1)*40; }
    rainGeo.attributes.position.needsUpdate=true;
  }
}
function updateWeather(dt){
  weatherTimer -= dt;
  if (weatherTimer<=0){ if (Math.random()<0.3) toggleRain(!raining); weatherTimer = 20 + Math.random()*25; }
}

/*** ---------- Movement & interaction ---------- ***/
function updatePlayer(dt){
  if (!controls.isLocked) return;
  const forward=new THREE.Vector3(), right=new THREE.Vector3();
  camera.getWorldDirection(forward); forward.y=0; forward.normalize();
  right.crossVectors(forward, new THREE.Vector3(0,1,0)).multiplyScalar(-1).normalize();
  const acc=new THREE.Vector3();
  if (keys.has('KeyW')) acc.add(forward);
  if (keys.has('KeyS')) acc.add(forward.clone().multiplyScalar(-1));
  if (keys.has('KeyA')) acc.add(right.clone().multiplyScalar(-1));
  if (keys.has('KeyD')) acc.add(right);
  if (acc.lengthSq()>0) acc.normalize().multiplyScalar(MOVE_ACCEL);
  vel.x += acc.x*dt; vel.z += acc.z*dt;
  vel.x -= vel.x*MOVE_DAMP*dt; vel.z -= vel.z*MOVE_DAMP*dt;
  vel.y -= GRAVITY*dt;
  if (keys.has('Space') && canJump){ vel.y=JUMP_VEL; canJump=false; }
  const pos=camera.position;
  pos.x += vel.x*dt; pos.z += vel.z*dt; pos.y += vel.y*dt;
  const groundY = heightAt(pos.x, pos.z) + PLAYER_HEIGHT;
  if (pos.y < groundY){ pos.y=groundY; vel.y=0; canJump=true; }
}
let pickupCooldown=0;
addEventListener('keydown', (e)=>{
  if (!controls.isLocked) return;
  if (e.code==='KeyE'){ tryPickup(); }
  else if (e.code==='KeyB'){ if (inventory.stick>=3 && inventory.rock>=1){ inventory.stick-=3; inventory.rock-=1; updateInventoryUI(); buildCampfireAt(camera.position.x, camera.position.z); } }
});
function tryPickup(){
  if (pickupCooldown>0) return;
  const n=nearestPickup(camera.position.x, camera.position.y, camera.position.z);
  if (n && n.dist<=PICKUP_DISTANCE){ const it=n.item; it.taken=true; scene.remove(it.mesh);
    inventory[it.type]=(inventory[it.type]||0)+1; updateInventoryUI(); pickupCooldown=0.2; }
}
function nearestPickup(px,py,pz){
  let best=null,bestD=1e9;
  for (const items of itemsMap.values()){
    for (const it of items){ if (it.taken) continue; const dx=it.x-px, dy=(it.y+0.3)-py, dz=it.z-pz; const d2=dx*dx+dy*dy+dz*dz;
      if (d2<bestD){ bestD=d2; best=it; } }
  }
  return best? {item:best, dist:Math.sqrt(bestD)} : null;
}

/*** ---------- Campfire ---------- ***/
function buildCampfireAt(x,z){
  const g=new THREE.CylinderGeometry(0.18,0.18,0.5,6), m=new THREE.MeshStandardMaterial({color:0x5a3d27,roughness:0.95});
  const log1=new THREE.Mesh(g,m), log2=log1.clone(), log3=log1.clone(); const y=heightAt(x,z)+0.25;
  log1.position.set(x,y,z); log2.position.set(x,y,z); log3.position.set(x,y,z);
  log1.rotation.z=0.4; log2.rotation.z=-0.4; log3.rotation.x=0.6; scene.add(log1,log2,log3);
  const flame=new THREE.Mesh(new THREE.SphereGeometry(0.22,16,12), new THREE.MeshBasicMaterial({color:0xffb74d}));
  flame.position.set(x,y+0.1,z); scene.add(flame);
  const glow=new THREE.PointLight(0xffa040,1.6,15,1.5); glow.position.set(x,y+0.3,z); scene.add(glow);
  const baseI=glow.intensity; campfires.push({ glow, flame, t: Math.random()*100, baseI });
}
const campfires=[]; function updateCampfires(dt){ for (const c of campfires){ c.t+=dt*8; c.glow.intensity=c.baseI*(0.75+Math.sin(c.t)*0.25+Math.random()*0.08); c.flame.scale.setScalar(0.8+Math.random()*0.2); } }

/*** ---------- Resize ---------- ***/
addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

/*** ---------- Start / Loop ---------- ***/
updateInventoryUI();
let elapsed=0, rainFallSpeed=18, chunkCheckTimer=0;
let timeOfDay=8.0;
function updateDayNight(dt){
  const minutesPerSec=(24/(DAY_MINUTES*60)); timeOfDay=(timeOfDay+dt*minutesPerSec*60)%24;
  const t=(timeOfDay/24)*Math.PI*2, elev=Math.sin(t), azim=Math.cos(t);
  sun.position.set(azim*200, Math.max(10, elev*220+120), elev*120);
  sun.intensity=clamp(0.1+Math.max(0,elev)*0.9,0.1,1.2); ambient.intensity=0.20+Math.max(0,elev)*0.25;
  const dayCol=new THREE.Color(0x88c6ff), duskCol=new THREE.Color(0xf5b080), nightCol=new THREE.Color(0x0b1020); let sky=dayCol.clone();
  if (elev<0.1){ sky.lerp(nightCol, clamp((0.1-elev)/0.6,0,1)); } else if (elev<0.3){ sky.lerp(duskCol, clamp((0.3-elev)/0.2,0,1)); }
  if (raining) sky.lerp(new THREE.Color(0x6a8bb3), 0.35);
  scene.background.copy(sky); scene.fog.color.copy(sky);
}
function animate(){
  const dt = Math.min(0.05, Math.max(0, clock.getDelta())); elapsed += dt;
  chunkCheckTimer -= dt; if (chunkCheckTimer<=0){ ensureChunksAround(camera.position.x, camera.position.z); chunkCheckTimer=0.25; }
  updateDayNight(dt); updateWeather(dt); updateCampfires(dt);
  if (water.material && water.material.uniforms && water.material.uniforms.time){ water.material.uniforms.time.value += dt; }
  if (raining){
    const arr=rainGeo.attributes.position.array;
    for (let i=0;i<MAX_RAIN;i++){
      arr[i*3+1] -= rainFallSpeed*dt;
      if (arr[i*3+1] < heightAt(arr[i*3+0],arr[i*3+2])+0.2){
        arr[i*3+0]=camera.position.x+(Math.random()*2-1)*40;
        arr[i*3+1]=camera.position.y+20+Math.random()*25;
        arr[i*3+2]=camera.position.z+(Math.random()*2-1)*40;
      }
    }
    rainGeo.attributes.position.needsUpdate=true;
  }
  updatePlayer(dt);
  if (pickupCooldown>0) pickupCooldown -= dt;
  const n=nearestPickup(camera.position.x, camera.position.y, camera.position.z);
  if (controls.isLocked && n && n.dist<=PICKUP_DISTANCE){ showInteract(`E — Pick up ${n.item.type.charAt(0).toUpperCase()+n.item.type.slice(1)}`); } else hideInteract();
  statusEl.textContent = `time ${timeOfDay.toFixed(1)}h | weather ${raining?'rain':'clear'} | x ${camera.position.x.toFixed(1)} z ${camera.position.z.toFixed(1)}`;
  for (let i=0;i<SWAY_MATERIALS.length;i++){ const mat = SWAY_MATERIALS[i]; const sh = mat.userData.shader; if (sh) sh.uniforms.uTime.value = elapsed; }
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
const clock = new THREE.Clock();
animate();
camera.position.set(8, PLAYER_HEIGHT+2, 8);
ensureChunksAround(camera.position.x, camera.position.z);
</script>
</body>
</html>
